<!DOCTYPE html>
<html class="writer-html5" lang="en" >
<head>
  <meta charset="utf-8" /><meta name="generator" content="Docutils 0.17: http://docutils.sourceforge.net/" />

  <meta name="viewport" content="width=device-width, initial-scale=1.0" />
  <title>9.1. 反射 &mdash; 运维开发修炼之路</title>
      <link rel="stylesheet" href="../../_static/pygments.css" type="text/css" />
      <link rel="stylesheet" href="../../_static/css/theme.css" type="text/css" />
  <!--[if lt IE 9]>
    <script src="../../_static/js/html5shiv.min.js"></script>
  <![endif]-->
  
        <script data-url_root="../../" id="documentation_options" src="../../_static/documentation_options.js"></script>
        <script src="../../_static/jquery.js"></script>
        <script src="../../_static/underscore.js"></script>
        <script src="../../_static/doctools.js"></script>
    <script src="../../_static/js/theme.js"></script>
    <link rel="index" title="Index" href="../../genindex.html" />
    <link rel="search" title="Search" href="../../search.html" />
    <link rel="next" title="10. 标准库和三方库" href="../10.%E6%A0%87%E5%87%86%E5%BA%93%E5%92%8C%E4%B8%89%E6%96%B9%E5%BA%93/index.html" />
    <link rel="prev" title="9. 反射" href="index.html" /> 
</head>

<body class="wy-body-for-nav"> 
  <div class="wy-grid-for-nav">
    <nav data-toggle="wy-nav-shift" class="wy-nav-side">
      <div class="wy-side-scroll">
        <div class="wy-side-nav-search" >
            <a href="../../index.html" class="icon icon-home"> 小健_Python_go_Devops
            <img src="../../_static/python_go.png" class="logo" alt="Logo"/>
          </a>
              <div class="version">
                2.0
              </div>
<div role="search">
  <form id="rtd-search-form" class="wy-form" action="../../search.html" method="get">
    <input type="text" name="q" placeholder="Search docs" />
    <input type="hidden" name="check_keywords" value="yes" />
    <input type="hidden" name="area" value="default" />
  </form>
</div>
        </div><div class="wy-menu wy-menu-vertical" data-spy="affix" role="navigation" aria-label="Navigation menu">
              <ul class="current">
<li class="toctree-l1 current"><a class="reference internal" href="../index.html">Go语言学习</a><ul class="current">
<li class="toctree-l2"><a class="reference internal" href="../01.Go%E8%AF%AD%E8%A8%80%E5%9F%BA%E6%9C%AC%E8%AF%AD%E6%B3%95/index.html">1. Go语言基本语法</a></li>
<li class="toctree-l2"><a class="reference internal" href="../02.%E5%AE%B9%E5%99%A8-%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/index.html">2. 容器-数据结构</a></li>
<li class="toctree-l2"><a class="reference internal" href="../03.%E6%B5%81%E7%A8%8B%E6%8E%A7%E5%88%B6/index.html">3. 流程控制</a></li>
<li class="toctree-l2"><a class="reference internal" href="../04.%E5%87%BD%E6%95%B0/index.html">4. 函数</a></li>
<li class="toctree-l2"><a class="reference internal" href="../05.%E7%BB%93%E6%9E%84%E4%BD%93/index.html">5. 结构体</a></li>
<li class="toctree-l2"><a class="reference internal" href="../06.%E6%8E%A5%E5%8F%A3/index.html">6. 接口</a></li>
<li class="toctree-l2"><a class="reference internal" href="../07.%E5%8C%85/index.html">7. 包</a></li>
<li class="toctree-l2"><a class="reference internal" href="../08.%E5%B9%B6%E5%8F%91/index.html">8. 并发</a></li>
<li class="toctree-l2 current"><a class="reference internal" href="index.html">9. 反射</a><ul class="current">
<li class="toctree-l3 current"><a class="current reference internal" href="#">9.1. 反射</a><ul>
<li class="toctree-l4"><a class="reference internal" href="#id2">9.1.1. 1.反射</a></li>
<li class="toctree-l4"><a class="reference internal" href="#reflect-type">9.1.2. 2. 反射的类型对象（reflect.Type）</a></li>
<li class="toctree-l4"><a class="reference internal" href="#reflect-value">9.1.3. 3.反射的值对象(reflect.Value)</a></li>
<li class="toctree-l4"><a class="reference internal" href="#json">9.1.4. 4 示例-将结构体的数据保存为JSON格式的文本数据</a></li>
</ul>
</li>
</ul>
</li>
<li class="toctree-l2"><a class="reference internal" href="../10.%E6%A0%87%E5%87%86%E5%BA%93%E5%92%8C%E4%B8%89%E6%96%B9%E5%BA%93/index.html">10. 标准库和三方库</a></li>
<li class="toctree-l2"><a class="reference internal" href="../11.%E9%A1%B9%E7%9B%AE%E4%BB%A3%E7%A0%81/index.html">11. 项目代码</a></li>
<li class="toctree-l2"><a class="reference internal" href="../12.%E9%81%BF%E5%9D%91%E4%B8%8E%E6%8A%80%E5%B7%A7/index.html">12. 避坑与技巧</a></li>
</ul>
</li>
<li class="toctree-l1"><a class="reference internal" href="../../Go_vs_Python/index.html">Go vs Python</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../Python/index.html">Python全栈系列</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../Python%E6%B5%8B%E8%AF%95%E5%BC%80%E5%8F%91%E5%85%A5%E9%97%A8%E4%B8%8E%E5%AE%9E%E8%B7%B5/index.html">Python测试开发入门与实践</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../Vue/index.html">Vue.js企业开发实战</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../Vue_Node.js/index.html">Vue.js+Node.js开发实战</a></li>
</ul>

        </div>
      </div>
    </nav>

    <section data-toggle="wy-nav-shift" class="wy-nav-content-wrap"><nav class="wy-nav-top" aria-label="Mobile navigation menu" >
          <i data-toggle="wy-nav-top" class="fa fa-bars"></i>
          <a href="../../index.html">小健_Python_go_Devops</a>
      </nav>

      <div class="wy-nav-content">
        <div class="rst-content">
          <div role="navigation" aria-label="Page navigation">
  <ul class="wy-breadcrumbs">
      <li><a href="../../index.html" class="icon icon-home"></a> &raquo;</li>
          <li><a href="../index.html">Go语言学习</a> &raquo;</li>
          <li><a href="index.html"><span class="section-number">9. </span>反射</a> &raquo;</li>
      <li><span class="section-number">9.1. </span>反射</li>
      <li class="wy-breadcrumbs-aside">
            <a href="../../_sources/Go/09.反射/01.反射.rst.txt" rel="nofollow"> View page source</a>
      </li>
  </ul>
  <hr/>
</div>
          <div role="main" class="document" itemscope="itemscope" itemtype="http://schema.org/Article">
           <div itemprop="articleBody">
             
  <div class="contents topic" id="contents">
<p class="topic-title">Contents</p>
<ul class="simple">
<li><p><a class="reference internal" href="#id1" id="id29">反射</a></p>
<ul>
<li><p><a class="reference internal" href="#id2" id="id30">1.反射</a></p></li>
<li><p><a class="reference internal" href="#reflect-type" id="id31">2. 反射的类型对象（reflect.Type）</a></p>
<ul>
<li><p><a class="reference internal" href="#type-kind" id="id32">2.1 理解反射的类型(Type)与种类(Kind)</a></p></li>
<li><p><a class="reference internal" href="#id5" id="id33">2.2 指针与指针指向的元素</a></p></li>
<li><p><a class="reference internal" href="#id6" id="id34">2.3 获取结构体的成员类型</a></p></li>
<li><p><a class="reference internal" href="#id9" id="id35">2.4. 结构体标签</a></p></li>
</ul>
</li>
<li><p><a class="reference internal" href="#reflect-value" id="id36">3.反射的值对象(reflect.Value)</a></p>
<ul>
<li><p><a class="reference internal" href="#id13" id="id37">3.1 使用反射值对象包装任意值</a></p></li>
<li><p><a class="reference internal" href="#id14" id="id38">3.2 从反射值对象获取被包装的值</a></p></li>
<li><p><a class="reference internal" href="#id17" id="id39">3.3 使用反射访问结构体的成员字段的值</a></p></li>
<li><p><a class="reference internal" href="#id18" id="id40">3.4 反射对象的空和有效性判断</a></p></li>
<li><p><a class="reference internal" href="#id19" id="id41">3.5 使用反射值对象修改变量的值</a></p></li>
<li><p><a class="reference internal" href="#id24" id="id42">3.6 通过类型创建类型的实例</a></p></li>
<li><p><a class="reference internal" href="#id25" id="id43">3.7 使用反射调用函数</a></p></li>
</ul>
</li>
<li><p><a class="reference internal" href="#json" id="id44">4 示例-将结构体的数据保存为JSON格式的文本数据</a></p>
<ul>
<li><p><a class="reference internal" href="#id26" id="id45">4.1 自己动手实现</a></p></li>
<li><p><a class="reference internal" href="#encoding-json" id="id46">4.2 使用encoding/json包</a></p></li>
</ul>
</li>
</ul>
</li>
</ul>
</div>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">package</span> <span class="n">main</span>

<span class="kn">import</span> <span class="p">(</span>
   <span class="s2">&quot;fmt&quot;</span>
   <span class="s2">&quot;reflect&quot;</span>
<span class="p">)</span>

<span class="n">func</span> <span class="n">main</span><span class="p">()</span> <span class="p">{</span>
   <span class="n">var</span> <span class="n">a</span> <span class="nb">int</span>

   <span class="o">//</span> <span class="n">取变量a的反射类型对象</span>
   <span class="n">typeOfA</span> <span class="o">:=</span> <span class="n">reflect</span><span class="o">.</span><span class="n">TypeOf</span><span class="p">(</span><span class="n">a</span><span class="p">)</span>

   <span class="o">//</span> <span class="n">根据反射类型对象创建类型实例</span>
   <span class="n">aIns</span> <span class="o">:=</span> <span class="n">reflect</span><span class="o">.</span><span class="n">New</span><span class="p">(</span><span class="n">typeOfA</span><span class="p">)</span>

   <span class="o">//</span> <span class="n">输出Value的类型和种类</span>
   <span class="n">fmt</span><span class="o">.</span><span class="n">Println</span><span class="p">(</span><span class="n">aIns</span><span class="o">.</span><span class="n">Type</span><span class="p">(),</span> <span class="n">aIns</span><span class="o">.</span><span class="n">Kind</span><span class="p">())</span>
<span class="p">}</span>
</pre></div>
</div>
<section id="id1">
<h1><a class="toc-backref" href="#id29"><span class="section-number">9.1. </span>反射</a><a class="headerlink" href="#id1" title="Permalink to this headline">¶</a></h1>
<section id="id2">
<span id="id3"></span><h2><a class="toc-backref" href="#id30"><span class="section-number">9.1.1. </span>1.反射</a><a class="headerlink" href="#id2" title="Permalink to this headline">¶</a></h2>
<p>反射是指在程序运行期对程序本身进行访问和修改的能力。程序在编译时，变量被转换为内存地址，变量名不会被编译器写入到可执行部分。在运行程序时，程序无法获取自身的信息。</p>
<p>支持反射的语言可以在程序编译期将变量的反射信息，如字段名称、类型信息、结构体信息等整合到可执行文件中，并给程序提供接口访问反射信息，这样就可以在程序运行期获取类型的反射信息，并且有能力修改它们。</p>
<p>Go程序在运行期使用reflect包访问程序的反射信息。</p>
<p>提示：C/C++语言没有支持反射功能，只能通过typeid提供非常弱化的程序运行时类型信息。Java、C#等语言都支持完整的反射功能。</p>
<p>Lua、JavaScript类动态语言，由于其本身的语法特性就可以让代码在运行期访问程序自身的值和类型信息，因此不需要反射系统。</p>
<p>Go程序的反射系统无法获取到一个可执行文件空间中或者是一个包中的所有类型信息，需要配合使用标准库中对应的词法、语法解析器和抽象语法树（AST）对源码进行扫描后获得这些信息。</p>
</section>
<section id="reflect-type">
<h2><a class="toc-backref" href="#id31"><span class="section-number">9.1.2. </span>2. 反射的类型对象（reflect.Type）</a><a class="headerlink" href="#reflect-type" title="Permalink to this headline">¶</a></h2>
<p>在Go程序中，使用reflect.TypeOf()函数可以获得任意值的类型对象（reflect.Type），程序通过类型对象可以访问任意值的类型信息。下面通过例子来理解获取类型对象的过程：</p>
<div class="highlight-go notranslate"><div class="highlight"><pre><span></span><span class="kn">package</span> <span class="nx">main</span>

<span class="kn">import</span> <span class="p">(</span>
    <span class="s">&quot;fmt&quot;</span>
    <span class="s">&quot;reflect&quot;</span>
<span class="p">)</span>

<span class="kd">func</span> <span class="nx">main</span><span class="p">()</span> <span class="p">{</span>

    <span class="kd">var</span> <span class="nx">a</span> <span class="kt">int</span>
    <span class="nx">typeOfA</span> <span class="o">:=</span> <span class="nx">reflect</span><span class="p">.</span><span class="nx">TypeOf</span><span class="p">(</span><span class="nx">a</span><span class="p">)</span>
    <span class="c1">// 通过typeOfA类型对象的成员函数，可以分别获取到typeOfA变量的类型名为int，种类（Kind）为int。</span>
    <span class="nx">fmt</span><span class="p">.</span><span class="nx">Println</span><span class="p">(</span><span class="nx">typeOfA</span><span class="p">.</span><span class="nx">Name</span><span class="p">(),</span><span class="nx">typeOfA</span><span class="p">.</span><span class="nx">Kind</span><span class="p">())</span>

<span class="p">}</span>
</pre></div>
</div>
<p>代码输出如下：</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="nb">int</span> <span class="nb">int</span>
</pre></div>
</div>
<section id="type-kind">
<h3><a class="toc-backref" href="#id32">2.1 理解反射的类型(Type)与种类(Kind)</a><a class="headerlink" href="#type-kind" title="Permalink to this headline">¶</a></h3>
<p>在使用反射时，需要首先理解类型（Type）和种类（Kind）的区别。编程中，使用最多的是类型，但在反射中，当需要区分一个大品种的类型时，就会用到种类（Kind）。</p>
<p>例如，需要统一判断类型中的指针时，使用种类（Kind）信息就较为方便。</p>
<section id="kind">
<h4>1 反射种类(Kind)的定义<a class="headerlink" href="#kind" title="Permalink to this headline">¶</a></h4>
<p>Go程序中的类型（Type）指的是系统原生数据类型，</p>
<p>如int、string、bool、float32等类型，以及使用type关键字定义的类型，这些类型的名称就是其类型本身的名称。</p>
<p>例如使用type A struct{}定义结构体时，A就是struct{}的类型。</p>
<p>种类（Kind）指的是对象归属的品种，在reflect包中有如下定义：</p>
<div class="highlight-go notranslate"><div class="highlight"><pre><span></span><span class="kd">type</span> <span class="nx">Kind</span> <span class="kt">uint</span>

<span class="kd">const</span> <span class="p">(</span>
        <span class="nx">Invalid</span> <span class="nx">Kind</span> <span class="p">=</span> <span class="kc">iota</span>                                 <span class="c1">// 非法类型</span>
        <span class="nx">Bool</span>                                                <span class="c1">// 布尔型</span>
        <span class="nx">Int</span>                                                 <span class="c1">// 有符号整型</span>
        <span class="nx">Int8</span>                                                <span class="c1">// 有符号8位整型</span>
        <span class="nx">Int16</span>                                               <span class="c1">// 有符号16位整型</span>
        <span class="nx">Int32</span>                                               <span class="c1">// 有符号32位整型</span>
        <span class="nx">Int64</span>                                               <span class="c1">// 有符号64位整型</span>
        <span class="nx">Uint</span>                                                <span class="c1">// 无符号整型</span>
        <span class="nx">Uint8</span>                                               <span class="c1">// 无符号8位整型</span>
        <span class="nx">Uint16</span>                                              <span class="c1">// 无符号16位整型</span>
        <span class="nx">Uint32</span>                                              <span class="c1">// 无符号32位整型</span>
        <span class="nx">Uint64</span>                                              <span class="c1">// 无符号64位整型</span>
        <span class="nx">Uintptr</span>                                             <span class="c1">// 指针</span>
        <span class="nx">Float32</span>                                             <span class="c1">// 单精度浮点数</span>
        <span class="nx">Float64</span>                                             <span class="c1">// 双精度浮点数</span>
        <span class="nx">Complex64</span>                                           <span class="c1">// 64位复数类型</span>
        <span class="nx">Complex128</span>                                          <span class="c1">// 128位复数类型</span>
        <span class="nx">Array</span>                                               <span class="c1">// 数组</span>
        <span class="nx">Chan</span>                                                <span class="c1">// 通道</span>
        <span class="nx">Func</span>                                                <span class="c1">// 函数</span>
        <span class="nx">Interface</span>                                           <span class="c1">// 接口</span>
        <span class="nx">Map</span>                                                 <span class="c1">// 映射</span>
        <span class="nx">Ptr</span>                                                 <span class="c1">// 指针</span>
        <span class="nx">Slice</span>                                               <span class="c1">// 切片</span>
        <span class="nx">String</span>                                              <span class="c1">// 字符串</span>
        <span class="nx">Struct</span>                                              <span class="c1">// 结构体</span>
        <span class="nx">UnsafePointer</span>                                       <span class="c1">// 底层指针</span>
<span class="p">)</span>
</pre></div>
</div>
<p>Map、Slice、Chan属于引用类型，使用起来类似于指针，但是在种类常量定义中仍然属于独立的种类，不属于Ptr。</p>
<p><code class="docutils literal notranslate"><span class="pre">type</span> <span class="pre">A</span> <span class="pre">struct{}定义的结构体属于Struct种类，*A属于Ptr</span></code>。</p>
</section>
<section id="id4">
<h4>2 从类型对象中获取类型名称和种类的例子<a class="headerlink" href="#id4" title="Permalink to this headline">¶</a></h4>
<p>Go语言中的类型名称对应的反射获取方法是reflect.Type中的Name()方法，返回表示类型名称的字符串。</p>
<p>类型归属的种类（Kind）使用的是reflect.Type中的Kind()方法，返回reflect.Kind类型的常量。</p>
<p>下面的代码中会对常量和结构体进行类型信息获取。</p>
<div class="highlight-go notranslate"><div class="highlight"><pre><span></span><span class="kn">package</span> <span class="nx">main</span>

<span class="kn">import</span> <span class="p">(</span>
    <span class="s">&quot;fmt&quot;</span>
    <span class="s">&quot;reflect&quot;</span>
<span class="p">)</span>

<span class="c1">// 定义一个Enum类型</span>
<span class="kd">type</span> <span class="nx">Enum</span> <span class="kt">int</span>

<span class="kd">const</span> <span class="p">(</span>
    <span class="nx">Zero</span>  <span class="nx">Enum</span> <span class="p">=</span> <span class="mi">0</span>
<span class="p">)</span>

<span class="kd">func</span> <span class="nx">main</span><span class="p">()</span> <span class="p">{</span>
    <span class="c1">// 声明一个空结构体</span>
    <span class="kd">type</span> <span class="nx">cat</span> <span class="kd">struct</span> <span class="p">{</span>
    <span class="p">}</span>

    <span class="c1">// 获取结构体实例的反射类型对象</span>
    <span class="nx">typeOfCat</span> <span class="o">:=</span> <span class="nx">reflect</span><span class="p">.</span><span class="nx">TypeOf</span><span class="p">(</span><span class="nx">cat</span><span class="p">{})</span>

    <span class="c1">// 显示反射类型对象的名称和种类</span>
    <span class="nx">fmt</span><span class="p">.</span><span class="nx">Println</span><span class="p">(</span><span class="nx">typeOfCat</span><span class="p">.</span><span class="nx">Name</span><span class="p">(),</span> <span class="nx">typeOfCat</span><span class="p">.</span><span class="nx">Kind</span><span class="p">())</span>

    <span class="c1">// 获取Zero常量的反射类型对象</span>
    <span class="nx">typeOfA</span> <span class="o">:=</span> <span class="nx">reflect</span><span class="p">.</span><span class="nx">TypeOf</span><span class="p">(</span><span class="nx">Zero</span><span class="p">)</span>

    <span class="c1">// 显示反射类型对象的名称和种类</span>
    <span class="nx">fmt</span><span class="p">.</span><span class="nx">Println</span><span class="p">(</span><span class="nx">typeOfA</span><span class="p">.</span><span class="nx">Name</span><span class="p">(),</span> <span class="nx">typeOfA</span><span class="p">.</span><span class="nx">Kind</span><span class="p">())</span>

<span class="p">}</span>
</pre></div>
</div>
<p>代码输出如下：</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">cat</span> <span class="n">struct</span>
<span class="n">Enum</span> <span class="nb">int</span>
</pre></div>
</div>
</section>
</section>
<section id="id5">
<h3><a class="toc-backref" href="#id33">2.2 指针与指针指向的元素</a><a class="headerlink" href="#id5" title="Permalink to this headline">¶</a></h3>
<p>Go程序中对指针获取反射对象时，可以通过reflect.Elem()方法获取这个指针指向的元素类型。</p>
<p>这个获取过程被称为取元素，等效于对指针类型变量做了一个”*”操作，代码如下：</p>
<div class="highlight-go notranslate"><div class="highlight"><pre><span></span><span class="kn">package</span> <span class="nx">main</span>

<span class="kn">import</span> <span class="p">(</span>
    <span class="s">&quot;fmt&quot;</span>
    <span class="s">&quot;reflect&quot;</span>
<span class="p">)</span>

<span class="kd">func</span> <span class="nx">main</span><span class="p">()</span> <span class="p">{</span>
    <span class="c1">// 声明一个空结构体</span>
    <span class="kd">type</span> <span class="nx">cat</span> <span class="kd">struct</span> <span class="p">{</span>
    <span class="p">}</span>

    <span class="c1">// 创建cat的实例</span>
    <span class="nx">ins</span> <span class="o">:=</span> <span class="o">&amp;</span><span class="nx">cat</span><span class="p">{}</span>

    <span class="c1">// 获取结构体实例的反射类型对象</span>
    <span class="nx">typeOfCat</span> <span class="o">:=</span> <span class="nx">reflect</span><span class="p">.</span><span class="nx">TypeOf</span><span class="p">(</span><span class="nx">ins</span><span class="p">)</span>

    <span class="c1">// 显示反射类型对象的名称和种类</span>
    <span class="c1">// 输出指针变量的类型名称和种类。Go语言的反射中对所有指针变量的种类都是Ptr，但注意，指针变量的类型名称是空，不是*cat。</span>
    <span class="nx">fmt</span><span class="p">.</span><span class="nx">Printf</span><span class="p">(</span><span class="s">&quot;name:&#39;%v&#39; kind:&#39;%v&#39;\n&quot;</span><span class="p">,</span> <span class="nx">typeOfCat</span><span class="p">.</span><span class="nx">Name</span><span class="p">(),</span> <span class="nx">typeOfCat</span><span class="p">.</span><span class="nx">Kind</span><span class="p">())</span>

    <span class="c1">// 取类型的元素</span>
    <span class="c1">// 取指针类型的元素类型，也就是cat类型。这个操作不可逆，不可以通过一个非指针类型获取它的指针类型。</span>
    <span class="nx">typeOfCat</span> <span class="p">=</span> <span class="nx">typeOfCat</span><span class="p">.</span><span class="nx">Elem</span><span class="p">()</span>

    <span class="c1">// 显示反射类型对象的名称和种类</span>
    <span class="nx">fmt</span><span class="p">.</span><span class="nx">Printf</span><span class="p">(</span><span class="s">&quot;element name: &#39;%v&#39;, element kind: &#39;%v&#39;\n&quot;</span><span class="p">,</span> <span class="nx">typeOfCat</span><span class="p">.</span><span class="nx">Name</span><span class="p">(),</span> <span class="nx">typeOfCat</span><span class="p">.</span><span class="nx">Kind</span><span class="p">())</span>

<span class="p">}</span>
</pre></div>
</div>
</section>
<section id="id6">
<h3><a class="toc-backref" href="#id34">2.3 获取结构体的成员类型</a><a class="headerlink" href="#id6" title="Permalink to this headline">¶</a></h3>
<p>任意值通过reflect.TypeOf()获得反射对象信息后，如果它的类型是结构体，可以通过反射值对象（reflect.Type）的NumField()和Field()方法获得结构体成员的详细信息。</p>
<p>与成员获取相关的reflect.Type的方法如表:</p>
<p>结构体成员访问的方法列表</p>
<img alt="../../_images/b10-1.png" src="../../_images/b10-1.png" />
<section id="id7">
<h4>1 结构体字段类型<a class="headerlink" href="#id7" title="Permalink to this headline">¶</a></h4>
<p>reflect.Type的Field()方法返回StructField结构，这个结构描述结构体的成员信息，通过这个信息可以获取成员与结构体的关系，如偏移、索引、是否为匿名字段、结构体标签（Struct
Tag）等，而且还可以通过StructField的Type字段进一步获取结构体成员的类型信息。StructField的结构如下：</p>
<div class="highlight-go notranslate"><div class="highlight"><pre><span></span><span class="kd">type</span> <span class="nx">StructField</span> <span class="kd">struct</span> <span class="p">{</span>
        <span class="nx">Name</span> <span class="kt">string</span>                                  <span class="c1">// 字段名</span>
        <span class="nx">PkgPath</span> <span class="kt">string</span>                               <span class="c1">// 字段路径</span>
        <span class="nx">Type</span>      <span class="nx">Type</span>                               <span class="c1">// 字段反射类型对象</span>
        <span class="nx">Tag</span>       <span class="nx">StructTag</span>                          <span class="c1">// 字段的结构体标签</span>
        <span class="nx">Offset</span>    <span class="kt">uintptr</span>                            <span class="c1">// 字段在结构体中的相对偏移</span>
        <span class="nx">Index</span>     <span class="p">[]</span><span class="kt">int</span>                              <span class="c1">// Type.FieldByIndex中的返回的索引值</span>
        <span class="nx">Anonymous</span> <span class="kt">bool</span>                               <span class="c1">// 是否为匿名字段</span>
<span class="p">}</span>
</pre></div>
</div>
<p>字段说明如下。</p>
<ul class="simple">
<li><p>Name：为字段名称。</p></li>
<li><p>PkgPath：字段在结构体中的路径</p></li>
<li><p>Type：字段本身的反射类型对象，类型为reflect.Type，可以进一步获取字段的类型信息。</p></li>
<li><p>Tag：结构体标签，为结构体字段标签的额外信息，可以单独提取。</p></li>
<li><p>Index：FieldByIndex中的索引顺序。</p></li>
<li><p>Anonymous：表示该字段是否为匿名字段。</p></li>
</ul>
</section>
<section id="id8">
<h4>2 获取成员反射信息<a class="headerlink" href="#id8" title="Permalink to this headline">¶</a></h4>
<p>下面代码中，实例化一个结构体并遍历其结构体成员，再通过reflect.Type的FieldByName()方法查找结构体中指定名称的字段，直接获取其类型信息。</p>
<div class="highlight-go notranslate"><div class="highlight"><pre><span></span><span class="kn">package</span> <span class="nx">main</span>

<span class="kn">import</span> <span class="p">(</span>
    <span class="s">&quot;fmt&quot;</span>
    <span class="s">&quot;reflect&quot;</span>
<span class="p">)</span>

<span class="kd">func</span> <span class="nx">main</span><span class="p">()</span> <span class="p">{</span>
    <span class="c1">// 声明一个空结构体</span>
    <span class="kd">type</span> <span class="nx">cat</span> <span class="kd">struct</span> <span class="p">{</span>
        <span class="nx">Name</span> <span class="kt">string</span>

        <span class="c1">// 带有结构体tag的字段</span>
        <span class="nx">Type</span> <span class="kt">int</span> <span class="s">`json:&quot;type&quot; id:&quot;100&quot;`</span>
    <span class="p">}</span>

    <span class="c1">// 创建cat的实例</span>
    <span class="nx">ins</span> <span class="o">:=</span> <span class="nx">cat</span><span class="p">{</span><span class="nx">Name</span><span class="p">:</span> <span class="s">&quot;mimi&quot;</span><span class="p">,</span> <span class="nx">Type</span><span class="p">:</span> <span class="mi">1</span><span class="p">}</span>

    <span class="c1">// 获取结构体实例的反射类型对象</span>
    <span class="nx">typeOfCat</span> <span class="o">:=</span> <span class="nx">reflect</span><span class="p">.</span><span class="nx">TypeOf</span><span class="p">(</span><span class="nx">ins</span><span class="p">)</span>

    <span class="c1">// 遍历结构体所有成员</span>
    <span class="k">for</span> <span class="nx">i</span> <span class="o">:=</span> <span class="mi">0</span><span class="p">;</span> <span class="nx">i</span> <span class="p">&lt;</span> <span class="nx">typeOfCat</span><span class="p">.</span><span class="nx">NumField</span><span class="p">();</span> <span class="nx">i</span><span class="o">++</span> <span class="p">{</span>
        <span class="c1">// 获取每个成员的结构体字段类型</span>
        <span class="nx">fieldType</span> <span class="o">:=</span> <span class="nx">typeOfCat</span><span class="p">.</span><span class="nx">Field</span><span class="p">(</span><span class="nx">i</span><span class="p">)</span>
        <span class="c1">// 输出成员名和tag</span>
        <span class="nx">fmt</span><span class="p">.</span><span class="nx">Printf</span><span class="p">(</span><span class="s">&quot;name: %v  tag: &#39;%v&#39;\n&quot;</span><span class="p">,</span> <span class="nx">fieldType</span><span class="p">.</span><span class="nx">Name</span><span class="p">,</span> <span class="nx">fieldType</span><span class="p">.</span><span class="nx">Tag</span><span class="p">)</span>
    <span class="p">}</span>

    <span class="c1">// 通过字段名，找到字段类型信息</span>
    <span class="k">if</span> <span class="nx">catType</span><span class="p">,</span> <span class="nx">ok</span> <span class="o">:=</span> <span class="nx">typeOfCat</span><span class="p">.</span><span class="nx">FieldByName</span><span class="p">(</span><span class="s">&quot;Type&quot;</span><span class="p">);</span> <span class="nx">ok</span> <span class="p">{</span>
        <span class="c1">// 从tag中取出需要的tag</span>
        <span class="nx">fmt</span><span class="p">.</span><span class="nx">Println</span><span class="p">(</span><span class="nx">catType</span><span class="p">.</span><span class="nx">Tag</span><span class="p">.</span><span class="nx">Get</span><span class="p">(</span><span class="s">&quot;json&quot;</span><span class="p">),</span> <span class="nx">catType</span><span class="p">.</span><span class="nx">Tag</span><span class="p">.</span><span class="nx">Get</span><span class="p">(</span><span class="s">&quot;id&quot;</span><span class="p">))</span>
    <span class="p">}</span>

<span class="p">}</span>
</pre></div>
</div>
<p>代码输出如下：</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">name</span><span class="p">:</span> <span class="n">Name</span>  <span class="n">tag</span><span class="p">:</span> <span class="s1">&#39;&#39;</span>
<span class="n">name</span><span class="p">:</span> <span class="n">Type</span>  <span class="n">tag</span><span class="p">:</span> <span class="s1">&#39;json:&quot;type&quot; id:&quot;100&quot;&#39;</span>
<span class="nb">type</span> <span class="mi">100</span>
</pre></div>
</div>
</section>
</section>
<section id="id9">
<h3><a class="toc-backref" href="#id35">2.4. 结构体标签</a><a class="headerlink" href="#id9" title="Permalink to this headline">¶</a></h3>
<p>通过reflect.Type获取结构体成员信息reflect.StructField结构中的Tag被称为结构体标签（Struct
Tag）。</p>
<p>JSON、BSON等格式进行序列化及对象关系映射（Object Relational
Mapping，简称ORM）系统都会用到结构体标签，这些系统使用标签设定字段在处理时应该具备的特殊属性和可能发生的行为。这些信息都是静态的，无须实例化结构体，可以通过反射获取到。</p>
<p>提示：结构体标签（Struct
Tag）类似于C#中的特性（Attribute）。C#允许在类、字段、方法等前面添加Attribute，然后在反射系统中可以获取到这个属性系统。例如：</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span>[Conditional(&quot;DEBUG&quot;)]
public static void Message(string msg)
{
        Console.WriteLine(msg)；
}
</pre></div>
</div>
<section id="id10">
<h4>1 结构体标签的格式<a class="headerlink" href="#id10" title="Permalink to this headline">¶</a></h4>
<p>Tag在结构体字段后方书写的格式如下：</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span>`key1:&quot;value1&quot; key2:&quot;value2&quot;`
</pre></div>
</div>
<p>结构体标签由一个或多个键值对组成。键与值使用冒号分隔，值用双引号括起来。键值对之间使用一个空格分隔。</p>
</section>
<section id="id11">
<h4>2 从结构体标签中获取值<a class="headerlink" href="#id11" title="Permalink to this headline">¶</a></h4>
<p>StructTag拥有一些方法，可以进行Tag信息的解析和提取，如下所示。</p>
<ul class="simple">
<li><p>func(tag StructTag)Get(key
string)string：根据Tag中的键获取对应的值，例如<code class="docutils literal notranslate"><span class="pre">key1:&quot;value1&quot;key2:&quot;value2&quot;</span></code>的Tag中，可以传入“key1”获得“value1”。</p></li>
<li><p>func(tag StructTag)Lookup(key string)(value string,ok
bool)：根据Tag中的键，查询值是否存在。</p></li>
</ul>
</section>
<section id="id12">
<h4>3. 结构体标签格式错误导致的问题<a class="headerlink" href="#id12" title="Permalink to this headline">¶</a></h4>
<p>编写Tag时，必须严格遵守键值对的规则。结构体标签的解析代码的容错能力很差，一旦格式写错，编译和运行时都不会提示任何错误，参见下面这个例子：</p>
<div class="highlight-go notranslate"><div class="highlight"><pre><span></span><span class="kn">package</span> <span class="nx">main</span>

<span class="kn">import</span> <span class="p">(</span>
    <span class="s">&quot;fmt&quot;</span>
    <span class="s">&quot;reflect&quot;</span>
<span class="p">)</span>

<span class="kd">func</span> <span class="nx">main</span><span class="p">()</span> <span class="p">{</span>
    <span class="c1">// 声明一个空结构体</span>
    <span class="kd">type</span> <span class="nx">cat</span> <span class="kd">struct</span> <span class="p">{</span>
        <span class="nx">Name</span> <span class="kt">string</span>

        <span class="c1">// 带有结构体tag的字段</span>
         <span class="c1">// 在json:和＂type＂之间增加了一个空格。这种写法没有遵守结构体标签的规则，因此无法通过Tag.Get获取到正确的json对应的值。</span>
        <span class="nx">Type</span> <span class="kt">int</span> <span class="s">`json: &quot;type&quot; id:&quot;100&quot;`</span>
    <span class="p">}</span>

    <span class="nx">typeOfCat</span> <span class="o">:=</span> <span class="nx">reflect</span><span class="p">.</span><span class="nx">TypeOf</span><span class="p">(</span><span class="nx">cat</span><span class="p">{})</span>

    <span class="k">if</span> <span class="nx">catType</span><span class="p">,</span> <span class="nx">ok</span> <span class="o">:=</span> <span class="nx">typeOfCat</span><span class="p">.</span><span class="nx">FieldByName</span><span class="p">(</span><span class="s">&quot;Type&quot;</span><span class="p">);</span> <span class="nx">ok</span> <span class="p">{</span>
        <span class="nx">fmt</span><span class="p">.</span><span class="nx">Println</span><span class="p">(</span><span class="nx">catType</span><span class="p">.</span><span class="nx">Tag</span><span class="p">.</span><span class="nx">Get</span><span class="p">(</span><span class="s">&quot;json&quot;</span><span class="p">))</span>
    <span class="p">}</span>

<span class="p">}</span>
</pre></div>
</div>
<p>代码输出空字符串，并不会输出期望的type。</p>
<p>这个错误在开发中非常容易被疏忽，造成难以察觉的错误。</p>
</section>
</section>
</section>
<section id="reflect-value">
<h2><a class="toc-backref" href="#id36"><span class="section-number">9.1.3. </span>3.反射的值对象(reflect.Value)</a><a class="headerlink" href="#reflect-value" title="Permalink to this headline">¶</a></h2>
<p>反射不仅可以获取值的类型信息，还可以动态地获取或者设置变量的值。Go语言中使用reflect.Value获取和设置变量的值。</p>
<section id="id13">
<h3><a class="toc-backref" href="#id37">3.1 使用反射值对象包装任意值</a><a class="headerlink" href="#id13" title="Permalink to this headline">¶</a></h3>
<p>Go语言中，使用reflect.ValueOf()函数获得值的反射值对象(reflect.Value)。书写格式如下：</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">value</span> <span class="o">:=</span> <span class="n">reflect</span><span class="o">.</span><span class="n">ValueOf</span><span class="p">(</span><span class="n">rawValue</span><span class="p">)</span>
</pre></div>
</div>
<p>reflect.ValueOf返回reflect.Value类型，包含有rawValue的值信息。</p>
<p>reflect.Value与原值间可以通过值包装和值获取互相转化。reflect.Value是一些反射操作的重要类型，如反射调用函数。</p>
</section>
<section id="id14">
<h3><a class="toc-backref" href="#id38">3.2 从反射值对象获取被包装的值</a><a class="headerlink" href="#id14" title="Permalink to this headline">¶</a></h3>
<p>Go语言中可以通过reflect.Value重新获得原始值。</p>
<section id="id15">
<h4>1.从反射值对象(reflect.Value)中获取值的方法<a class="headerlink" href="#id15" title="Permalink to this headline">¶</a></h4>
<p>可以通过下面几种方法从反射值对象reflect.Value中获取原值，如表</p>
<p>反射值获取原始值的方法</p>
<img alt="../../_images/b10-2.png" src="../../_images/b10-2.png" />
</section>
<section id="id16">
<h4>2.从反射值对象(reflect.Value)中获取值的例子<a class="headerlink" href="#id16" title="Permalink to this headline">¶</a></h4>
<p>下面代码中，将整型变量中的值使用reflect.Value获取反射值对象(reflect.Value)。</p>
<p>再通过reflect.Value的Interface()方法获得interface{}类型的原值，通过int类型对应的reflect.Value的Int()方法获得整型值。</p>
<div class="highlight-go notranslate"><div class="highlight"><pre><span></span><span class="kn">package</span> <span class="nx">main</span>

<span class="kn">import</span> <span class="p">(</span>
    <span class="s">&quot;fmt&quot;</span>
    <span class="s">&quot;reflect&quot;</span>
<span class="p">)</span>

<span class="kd">func</span> <span class="nx">main</span><span class="p">()</span> <span class="p">{</span>
    <span class="c1">// 声明整型变量a并赋初值</span>
    <span class="kd">var</span> <span class="nx">a</span> <span class="kt">int</span> <span class="p">=</span> <span class="mi">1024</span>

    <span class="c1">// 获取变量a的反射值对象</span>
    <span class="nx">valueOfA</span> <span class="o">:=</span> <span class="nx">reflect</span><span class="p">.</span><span class="nx">ValueOf</span><span class="p">(</span><span class="nx">a</span><span class="p">)</span>

    <span class="c1">// 获取interface{}类型的值，通过类型断言转换</span>
    <span class="c1">// 将valueOfA反射值对象以interface{}类型取出，通过类型断言转换为int类型并赋值给getA。</span>
    <span class="kd">var</span> <span class="nx">getA</span> <span class="kt">int</span> <span class="p">=</span> <span class="nx">valueOfA</span><span class="p">.</span><span class="nx">Interface</span><span class="p">().(</span><span class="kt">int</span><span class="p">)</span>

    <span class="c1">// 获取64位的值，强制类型转换为int类型</span>
    <span class="c1">// 将valueOfA反射值对象通过Int方法，以int64类型取出，通过强制类型转换，转换为原本的int类型。</span>
    <span class="kd">var</span> <span class="nx">getA2</span> <span class="kt">int</span> <span class="p">=</span> <span class="nb">int</span><span class="p">(</span><span class="nx">valueOfA</span><span class="p">.</span><span class="nx">Int</span><span class="p">())</span>

    <span class="nx">fmt</span><span class="p">.</span><span class="nx">Println</span><span class="p">(</span><span class="nx">getA</span><span class="p">,</span> <span class="nx">getA2</span><span class="p">)</span>

<span class="p">}</span>
</pre></div>
</div>
<p>代码输出如下：</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="mi">1024</span> <span class="mi">1024</span>
</pre></div>
</div>
</section>
</section>
<section id="id17">
<h3><a class="toc-backref" href="#id39">3.3 使用反射访问结构体的成员字段的值</a><a class="headerlink" href="#id17" title="Permalink to this headline">¶</a></h3>
<p>反射值对象(reflect.Value)提供对结构体访问的方法，通过这些方法可以完成对结构体任意值的访问，如表</p>
<p>反射值对象的成员访问方法</p>
<img alt="../../_images/b10-3.png" src="../../_images/b10-3.png" />
<p>下面代码构造一个结构体包含不同类型的成员。通过reflect.Value提供的成员访问函数，可以获得结构体值的各种数据。</p>
<div class="highlight-go notranslate"><div class="highlight"><pre><span></span><span class="kn">package</span> <span class="nx">main</span>

<span class="kn">import</span> <span class="p">(</span>
    <span class="s">&quot;fmt&quot;</span>
    <span class="s">&quot;reflect&quot;</span>
<span class="p">)</span>

<span class="c1">// 定义结构体</span>
<span class="kd">type</span> <span class="nx">dummy</span> <span class="kd">struct</span> <span class="p">{</span>
    <span class="nx">a</span> <span class="kt">int</span>
    <span class="nx">b</span> <span class="kt">string</span>
    <span class="c1">// 嵌入字段</span>
    <span class="kt">float32</span>
    <span class="kt">bool</span>
    <span class="nx">next</span> <span class="o">*</span><span class="nx">dummy</span>
<span class="p">}</span>

<span class="kd">func</span> <span class="nx">main</span><span class="p">()</span> <span class="p">{</span>
    <span class="c1">// 值包装结构体</span>
    <span class="nx">d</span> <span class="o">:=</span> <span class="nx">reflect</span><span class="p">.</span><span class="nx">ValueOf</span><span class="p">(</span><span class="nx">dummy</span><span class="p">{</span>
        <span class="nx">next</span><span class="p">:</span> <span class="o">&amp;</span><span class="nx">dummy</span><span class="p">{},</span>
    <span class="p">})</span>

    <span class="c1">// 获取字段数量</span>
    <span class="nx">fmt</span><span class="p">.</span><span class="nx">Println</span><span class="p">(</span><span class="s">&quot;NumField&quot;</span><span class="p">,</span> <span class="nx">d</span><span class="p">.</span><span class="nx">NumField</span><span class="p">())</span>

    <span class="c1">// 获取索引为2的字段（float32字段）</span>
    <span class="nx">floatField</span> <span class="o">:=</span> <span class="nx">d</span><span class="p">.</span><span class="nx">Field</span><span class="p">(</span><span class="mi">2</span><span class="p">)</span>

    <span class="c1">// 输出字段类型</span>
    <span class="nx">fmt</span><span class="p">.</span><span class="nx">Println</span><span class="p">(</span><span class="s">&quot;Field&quot;</span><span class="p">,</span> <span class="nx">floatField</span><span class="p">.</span><span class="nx">Type</span><span class="p">())</span>

    <span class="c1">// 根据名字查找字段</span>
    <span class="nx">fmt</span><span class="p">.</span><span class="nx">Println</span><span class="p">(</span><span class="s">&quot;FieldByName(\&quot;b\&quot;).Type&quot;</span><span class="p">,</span> <span class="nx">d</span><span class="p">.</span><span class="nx">FieldByName</span><span class="p">(</span><span class="s">&quot;b&quot;</span><span class="p">).</span><span class="nx">Type</span><span class="p">())</span>

    <span class="c1">// 根据索引查找值中，next字段的int字段的值</span>
    <span class="c1">// []int{4,0}中的4表示，在dummy结构中索引值为4的成员，也就是next。next的类型为dummy，也是一个结构体，因此使用[]int{4,0}中的0继续在next值的基础上索引，结构为dummy中索引值为0的a字段，类型为int。</span>
    <span class="nx">fmt</span><span class="p">.</span><span class="nx">Println</span><span class="p">(</span><span class="s">&quot;FieldByIndex([]int{4, 0}).Type()&quot;</span><span class="p">,</span> <span class="nx">d</span><span class="p">.</span><span class="nx">FieldByIndex</span><span class="p">([]</span><span class="kt">int</span><span class="p">{</span><span class="mi">4</span><span class="p">,</span> <span class="mi">0</span><span class="p">}).</span><span class="nx">Type</span><span class="p">())</span>

<span class="p">}</span>
</pre></div>
</div>
<p>代码输出如下</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">NumField</span> <span class="mi">5</span>
<span class="n">Field</span> <span class="n">float32</span>
<span class="n">FieldByName</span><span class="p">(</span><span class="s2">&quot;b&quot;</span><span class="p">)</span><span class="o">.</span><span class="n">Type</span> <span class="n">string</span>
<span class="n">FieldByIndex</span><span class="p">([]</span><span class="nb">int</span><span class="p">{</span><span class="mi">4</span><span class="p">,</span> <span class="mi">0</span><span class="p">})</span><span class="o">.</span><span class="n">Type</span><span class="p">()</span> <span class="nb">int</span>
</pre></div>
</div>
</section>
<section id="id18">
<h3><a class="toc-backref" href="#id40">3.4 反射对象的空和有效性判断</a><a class="headerlink" href="#id18" title="Permalink to this headline">¶</a></h3>
<p>反射值对象（reflect.Value）提供一系列方法进行零值和空判定，如表</p>
<img alt="../../_images/b10-4.png" src="../../_images/b10-4.png" />
<p>下面的例子将会对各种方式的空指针进行IsNil和IsValid的返回值判定检测。同时对结构体成员及方法查找map键值对的返回值进行IsValid判定，参考代码</p>
<div class="highlight-go notranslate"><div class="highlight"><pre><span></span><span class="kn">package</span> <span class="nx">main</span>

<span class="kn">import</span> <span class="p">(</span>
    <span class="s">&quot;fmt&quot;</span>
    <span class="s">&quot;reflect&quot;</span>
<span class="p">)</span>

<span class="kd">func</span> <span class="nx">main</span><span class="p">()</span> <span class="p">{</span>

    <span class="c1">// *int的空指针</span>
    <span class="kd">var</span> <span class="nx">a</span> <span class="o">*</span><span class="kt">int</span>
    <span class="nx">fmt</span><span class="p">.</span><span class="nx">Println</span><span class="p">(</span><span class="s">&quot;var a *int:&quot;</span><span class="p">,</span> <span class="nx">reflect</span><span class="p">.</span><span class="nx">ValueOf</span><span class="p">(</span><span class="nx">a</span><span class="p">).</span><span class="nx">IsNil</span><span class="p">())</span>

    <span class="c1">// nil值</span>
    <span class="nx">fmt</span><span class="p">.</span><span class="nx">Println</span><span class="p">(</span><span class="s">&quot;nil:&quot;</span><span class="p">,</span> <span class="nx">reflect</span><span class="p">.</span><span class="nx">ValueOf</span><span class="p">(</span><span class="kc">nil</span><span class="p">).</span><span class="nx">IsValid</span><span class="p">())</span>

    <span class="c1">// *int类型的空指针</span>
    <span class="nx">fmt</span><span class="p">.</span><span class="nx">Println</span><span class="p">(</span><span class="s">&quot;(*int)(nil):&quot;</span><span class="p">,</span> <span class="nx">reflect</span><span class="p">.</span><span class="nx">ValueOf</span><span class="p">((</span><span class="o">*</span><span class="kt">int</span><span class="p">)(</span><span class="kc">nil</span><span class="p">)).</span><span class="nx">Elem</span><span class="p">().</span><span class="nx">IsValid</span><span class="p">())</span>

    <span class="c1">// 实例化一个结构体</span>
    <span class="nx">s</span> <span class="o">:=</span> <span class="kd">struct</span><span class="p">{}{}</span>

    <span class="c1">// 尝试从结构体中查找一个不存在的字段</span>
    <span class="nx">fmt</span><span class="p">.</span><span class="nx">Println</span><span class="p">(</span><span class="s">&quot;不存在的结构体成员:&quot;</span><span class="p">,</span> <span class="nx">reflect</span><span class="p">.</span><span class="nx">ValueOf</span><span class="p">(</span><span class="nx">s</span><span class="p">).</span><span class="nx">FieldByName</span><span class="p">(</span><span class="s">&quot;&quot;</span><span class="p">).</span><span class="nx">IsValid</span><span class="p">())</span>

    <span class="c1">// 实例化一个map</span>
    <span class="nx">m</span> <span class="o">:=</span> <span class="kd">map</span><span class="p">[</span><span class="kt">int</span><span class="p">]</span><span class="kt">int</span><span class="p">{}</span>

    <span class="c1">// 尝试从map中查找一个不存在的键</span>
    <span class="nx">fmt</span><span class="p">.</span><span class="nx">Println</span><span class="p">(</span><span class="s">&quot;不存在的键：&quot;</span><span class="p">,</span> <span class="nx">reflect</span><span class="p">.</span><span class="nx">ValueOf</span><span class="p">(</span><span class="nx">m</span><span class="p">).</span><span class="nx">MapIndex</span><span class="p">(</span><span class="nx">reflect</span><span class="p">.</span><span class="nx">ValueOf</span><span class="p">(</span><span class="mi">3</span><span class="p">)).</span><span class="nx">IsValid</span><span class="p">())</span>
<span class="p">}</span>
</pre></div>
</div>
<p>IsNil常被用于判断指针是否为空；IsValid常被用于判定返回值是否有效。</p>
<p>代码输出如下：</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span>var a *int: true
nil: false
(*int)(nil): false
不存在的结构体成员: false
不存在的结构体方法: false
不存在的键： false
</pre></div>
</div>
</section>
<section id="id19">
<h3><a class="toc-backref" href="#id41">3.5 使用反射值对象修改变量的值</a><a class="headerlink" href="#id19" title="Permalink to this headline">¶</a></h3>
<p>使用reflect.Value对包装的值进行修改时，需要遵循一些规则。如果没有按照规则进行代码设计和编写，轻则无法修改对象值，重则程序在运行时会发生宕机。</p>
<section id="id20">
<h4>1.判定及获取元素的相关方法<a class="headerlink" href="#id20" title="Permalink to this headline">¶</a></h4>
<p>使用reflect.Value取元素、取地址及修改值的属性方法请参考表</p>
<p>反射值对象的判定及获取元素的方法</p>
<img alt="../../_images/b10-5.png" src="../../_images/b10-5.png" />
</section>
<section id="id21">
<h4>2.值修改相关方法<a class="headerlink" href="#id21" title="Permalink to this headline">¶</a></h4>
<p>使用reflect.Value修改值的相关方法如表</p>
<p>反射值对象修改值的方法</p>
<img alt="../../_images/b10-6.png" src="../../_images/b10-6.png" />
<p>以上方法，在reflect.Value的CanSet返回false仍然修改值时会发生宕机。</p>
<p>在已知值的类型时，应尽量使用值对应类型的反射设置值。</p>
</section>
<section id="id22">
<h4>3.值可修改条件之一：可被寻址<a class="headerlink" href="#id22" title="Permalink to this headline">¶</a></h4>
<p>通过反射修改变量值的前提条件之一：这个值必须可以被寻址。简单地说就是这个变量必须能被修改。示例代码如下：</p>
<div class="highlight-go notranslate"><div class="highlight"><pre><span></span><span class="kn">package</span> <span class="nx">main</span>

<span class="kn">import</span> <span class="s">&quot;reflect&quot;</span>

<span class="kd">func</span> <span class="nx">main</span><span class="p">()</span> <span class="p">{</span>
    <span class="c1">// 声明整型变量a并赋初值</span>
    <span class="kd">var</span> <span class="nx">a</span> <span class="kt">int</span> <span class="p">=</span> <span class="mi">1024</span>

    <span class="c1">// 获取变量a的反射值对象</span>
    <span class="nx">valueOfA</span> <span class="o">:=</span> <span class="nx">reflect</span><span class="p">.</span><span class="nx">ValueOf</span><span class="p">(</span><span class="nx">a</span><span class="p">)</span>

    <span class="c1">// 尝试将a修改为1（此处会发生崩溃）</span>
    <span class="nx">valueOfA</span><span class="p">.</span><span class="nx">SetInt</span><span class="p">(</span><span class="mi">1</span><span class="p">)</span>
<span class="p">}</span>
</pre></div>
</div>
<p>程序运行崩溃，打印错误：</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">panic</span><span class="p">:</span> <span class="n">reflect</span><span class="p">:</span> <span class="n">reflect</span><span class="o">.</span><span class="n">Value</span><span class="o">.</span><span class="n">SetInt</span> <span class="n">using</span> <span class="n">unaddressable</span> <span class="n">value</span>
</pre></div>
</div>
<p>报错意思是：SetInt正在使用一个不能被寻址的值。从reflect.ValueOf传入的是a的值，而不是a的地址，这个reflect.Value当然是不能被寻址的。将代码修改一下，重新运行：</p>
<div class="highlight-go notranslate"><div class="highlight"><pre><span></span><span class="kn">package</span> <span class="nx">main</span>

<span class="kn">import</span> <span class="p">(</span>
    <span class="s">&quot;fmt&quot;</span>
    <span class="s">&quot;reflect&quot;</span>
<span class="p">)</span>

<span class="kd">func</span> <span class="nx">main</span><span class="p">()</span> <span class="p">{</span>
    <span class="c1">// 声明整型变量a并赋初值</span>
    <span class="kd">var</span> <span class="nx">a</span> <span class="kt">int</span> <span class="p">=</span> <span class="mi">1024</span>

    <span class="c1">// 获取变量a的反射值对象（a的地址）</span>
    <span class="nx">valueOfA</span> <span class="o">:=</span> <span class="nx">reflect</span><span class="p">.</span><span class="nx">ValueOf</span><span class="p">(</span><span class="o">&amp;</span><span class="nx">a</span><span class="p">)</span>

    <span class="c1">// 取出a地址的元素（a的值）</span>
    <span class="c1">// 使用reflect.Value类型的Elem()方法获取a地址的元素，也就是a的值。reflect.Value的Elem()方法返回的值类型也是reflect.Value。</span>
    <span class="nx">valueOfA</span> <span class="p">=</span> <span class="nx">valueOfA</span><span class="p">.</span><span class="nx">Elem</span><span class="p">()</span>

    <span class="c1">// 尝试将a修改为1</span>
    <span class="c1">// 此时valueOfA表示的是a的值且可以寻址。使用SetInt()方法设置值时不再发生崩溃。</span>
    <span class="nx">valueOfA</span><span class="p">.</span><span class="nx">SetInt</span><span class="p">(</span><span class="mi">1</span><span class="p">)</span>

    <span class="c1">// 打印a的值</span>
    <span class="nx">fmt</span><span class="p">.</span><span class="nx">Println</span><span class="p">(</span><span class="nx">valueOfA</span><span class="p">.</span><span class="nx">Int</span><span class="p">())</span>
<span class="p">}</span>
</pre></div>
</div>
<p>代码输出如下：</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="mi">1</span>
</pre></div>
</div>
<p>提示：当reflect.Value不可寻址时，使用Addr()方法也是无法取到值的地址的，同时会发生宕机。</p>
<p>虽然说reflect.Value的Addr()方法类似于语言层的“&amp;”操作；Elem()方法类似于语言层的“*”操作，但并不代表这些方法与语言层操作等效。</p>
</section>
<section id="id23">
<h4>4.值可修改条件之一：被导出<a class="headerlink" href="#id23" title="Permalink to this headline">¶</a></h4>
<p>结构体成员中，如果字段没有被导出，即便不使用反射也可以被访问，但不能通过反射修改，代码如下：</p>
<div class="highlight-go notranslate"><div class="highlight"><pre><span></span><span class="kn">package</span> <span class="nx">main</span>

<span class="kn">import</span> <span class="s">&quot;reflect&quot;</span>

<span class="kd">func</span> <span class="nx">main</span><span class="p">()</span> <span class="p">{</span>
    <span class="kd">type</span> <span class="nx">dog</span> <span class="kd">struct</span> <span class="p">{</span>
        <span class="nx">legCount</span> <span class="kt">int</span>
    <span class="p">}</span>

    <span class="c1">// 获取dog实例的反射值对象</span>
    <span class="nx">valueOfDog</span> <span class="o">:=</span> <span class="nx">reflect</span><span class="p">.</span><span class="nx">ValueOf</span><span class="p">(</span><span class="nx">dog</span><span class="p">{})</span>

    <span class="c1">// 获取legCount字段的值</span>
    <span class="nx">vLegCount</span> <span class="o">:=</span> <span class="nx">valueOfDog</span><span class="p">.</span><span class="nx">FieldByName</span><span class="p">(</span><span class="s">&quot;legCount&quot;</span><span class="p">)</span>

    <span class="c1">// 尝试设置legCount的值（这里会发生崩溃）</span>
    <span class="nx">vLegCount</span><span class="p">.</span><span class="nx">SetInt</span><span class="p">(</span><span class="mi">4</span><span class="p">)</span>
<span class="p">}</span>
</pre></div>
</div>
<p>程序发生崩溃，报错：</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">panic</span><span class="p">:</span> <span class="n">reflect</span><span class="p">:</span> <span class="n">reflect</span><span class="o">.</span><span class="n">Value</span><span class="o">.</span><span class="n">SetInt</span> <span class="n">using</span> <span class="n">value</span> <span class="n">obtained</span> <span class="n">using</span> <span class="n">unexported</span>
<span class="n">field</span>
</pre></div>
</div>
<p>报错的意思是：SetInt()使用的值来自于一个未导出的字段。</p>
<p>为了能修改这个值，需要将该字段导出。将dog中的legCount的成员首字母大写，导出LegCount让反射可以访问，修改后的代码如下：</p>
<div class="highlight-go notranslate"><div class="highlight"><pre><span></span><span class="kd">type</span> <span class="nx">dog</span> <span class="kd">struct</span> <span class="p">{</span>
    <span class="nx">LegCount</span> <span class="kt">int</span>
<span class="p">}</span>
</pre></div>
</div>
<p>然后根据字段名获取字段的值时，将字符串的字段首字母大写，修改后的代码如下：</p>
<div class="highlight-go notranslate"><div class="highlight"><pre><span></span><span class="kn">package</span> <span class="nx">main</span>

<span class="kn">import</span> <span class="s">&quot;reflect&quot;</span>

<span class="kd">func</span> <span class="nx">main</span><span class="p">()</span> <span class="p">{</span>
    <span class="kd">type</span> <span class="nx">dog</span> <span class="kd">struct</span> <span class="p">{</span>
        <span class="nx">LegCount</span> <span class="kt">int</span>
    <span class="p">}</span>

    <span class="c1">// 获取dog实例的反射值对象</span>
    <span class="nx">valueOfDog</span> <span class="o">:=</span> <span class="nx">reflect</span><span class="p">.</span><span class="nx">ValueOf</span><span class="p">(</span><span class="nx">dog</span><span class="p">{})</span>

    <span class="c1">// 获取legCount字段的值</span>
    <span class="nx">vLegCount</span> <span class="o">:=</span> <span class="nx">valueOfDog</span><span class="p">.</span><span class="nx">FieldByName</span><span class="p">(</span><span class="s">&quot;LegCount&quot;</span><span class="p">)</span>

    <span class="c1">// 尝试设置legCount的值（这里会发生崩溃）</span>
    <span class="nx">vLegCount</span><span class="p">.</span><span class="nx">SetInt</span><span class="p">(</span><span class="mi">4</span><span class="p">)</span>
<span class="p">}</span>
</pre></div>
</div>
<p>再次运行程序，发现仍然报错：</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">panic</span><span class="p">:</span> <span class="n">reflect</span><span class="p">:</span> <span class="n">reflect</span><span class="o">.</span><span class="n">Value</span><span class="o">.</span><span class="n">SetInt</span> <span class="n">using</span> <span class="n">unaddressable</span> <span class="n">value</span>
</pre></div>
</div>
<p>这个错误表示构造的valueOfDog这个结构体实例不能被寻址，因此其字段也不能被修改。</p>
<p>修改代码，取结构体的指针，再通过reflect.Value的Elem()方法取到值的反射值对象。修改后的完整代码如下：</p>
<div class="highlight-go notranslate"><div class="highlight"><pre><span></span><span class="kn">package</span> <span class="nx">main</span>

<span class="kn">import</span> <span class="p">(</span>
    <span class="s">&quot;fmt&quot;</span>
    <span class="s">&quot;reflect&quot;</span>
<span class="p">)</span>

<span class="kd">func</span> <span class="nx">main</span><span class="p">()</span> <span class="p">{</span>
    <span class="kd">type</span> <span class="nx">dog</span> <span class="kd">struct</span> <span class="p">{</span>
        <span class="nx">LegCount</span> <span class="kt">int</span>
    <span class="p">}</span>

    <span class="c1">// 获取dog实例的反射值对象</span>
    <span class="nx">valueOfDog</span> <span class="o">:=</span> <span class="nx">reflect</span><span class="p">.</span><span class="nx">ValueOf</span><span class="p">(</span><span class="o">&amp;</span><span class="nx">dog</span><span class="p">{})</span>

    <span class="c1">// 取出dog实例地址的元素</span>
    <span class="nx">valueOfDog</span> <span class="p">=</span> <span class="nx">valueOfDog</span><span class="p">.</span><span class="nx">Elem</span><span class="p">()</span>

    <span class="c1">// 获取legCount字段的值</span>
    <span class="nx">vLegCount</span> <span class="o">:=</span> <span class="nx">valueOfDog</span><span class="p">.</span><span class="nx">FieldByName</span><span class="p">(</span><span class="s">&quot;LegCount&quot;</span><span class="p">)</span>

    <span class="c1">// 尝试设置legCount的值（这里会发生崩溃）</span>
    <span class="nx">vLegCount</span><span class="p">.</span><span class="nx">SetInt</span><span class="p">(</span><span class="mi">4</span><span class="p">)</span>

    <span class="nx">fmt</span><span class="p">.</span><span class="nx">Println</span><span class="p">(</span><span class="nx">vLegCount</span><span class="p">.</span><span class="nx">Int</span><span class="p">())</span>
<span class="p">}</span>
</pre></div>
</div>
<p>代码输出如下：</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="mi">4</span>
</pre></div>
</div>
<p>值的修改从表面意义上叫可寻址，换一种说法就是值必须“可被设置”。那么，想修改变量值，一般的步骤是：</p>
<p>（1）取这个变量的地址或者这个变量所在的结构体已经是指针类型。</p>
<p>（2）使用reflect.ValueOf进行值包装。</p>
<p>（3）通过Value.Elem()获得指针值指向的元素值对象（Value），因为值对象（Value）内部对象为指针时，使用set设置时会报出宕机错误。</p>
<p>（4）使用Value.Set设置值。</p>
</section>
</section>
<section id="id24">
<h3><a class="toc-backref" href="#id42">3.6 通过类型创建类型的实例</a><a class="headerlink" href="#id24" title="Permalink to this headline">¶</a></h3>
<p>当已知reflect.Type时，可以动态地创建这个类型的实例，实例的类型为指针。</p>
<p>例如reflect.Type的类型为int时，创建int的指针，即*int，代码如下：</p>
<div class="highlight-go notranslate"><div class="highlight"><pre><span></span><span class="kn">package</span> <span class="nx">main</span>

<span class="kn">import</span> <span class="p">(</span>
    <span class="s">&quot;fmt&quot;</span>
    <span class="s">&quot;reflect&quot;</span>
<span class="p">)</span>

<span class="kd">func</span> <span class="nx">main</span><span class="p">()</span> <span class="p">{</span>
    <span class="kd">var</span> <span class="nx">a</span> <span class="kt">int</span>

    <span class="c1">// 取变量a的反射类型对象</span>
    <span class="nx">typeOfA</span> <span class="o">:=</span> <span class="nx">reflect</span><span class="p">.</span><span class="nx">TypeOf</span><span class="p">(</span><span class="nx">a</span><span class="p">)</span>

    <span class="c1">// 根据反射类型对象创建类型实例</span>
    <span class="c1">// 使用reflect.New()函数传入变量a的反射类型对象，创建这个类型的实例值，值以reflect.Value类型返回。</span>
    <span class="c1">// 这步操作等效于：new(int) 因此返回的是*int类型的实例。</span>
    <span class="nx">aIns</span> <span class="o">:=</span> <span class="nx">reflect</span><span class="p">.</span><span class="nx">New</span><span class="p">(</span><span class="nx">typeOfA</span><span class="p">)</span>

    <span class="c1">// 输出Value的类型和种类</span>
    <span class="c1">// 打印aIns的类型为*int，种类为指针。</span>
    <span class="nx">fmt</span><span class="p">.</span><span class="nx">Println</span><span class="p">(</span><span class="nx">aIns</span><span class="p">.</span><span class="nx">Type</span><span class="p">(),</span> <span class="nx">aIns</span><span class="p">.</span><span class="nx">Kind</span><span class="p">())</span>
<span class="p">}</span>
</pre></div>
</div>
<p>代码输出如下：</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="o">*</span><span class="nb">int</span> <span class="n">ptr</span>
</pre></div>
</div>
</section>
<section id="id25">
<h3><a class="toc-backref" href="#id43">3.7 使用反射调用函数</a><a class="headerlink" href="#id25" title="Permalink to this headline">¶</a></h3>
<p>如果反射值对象（reflect.Value）中值的类型为函数时，可以通过reflect.Value调用该函数。</p>
<p>使用反射调用函数时，需要将参数使用反射值对象的切片[]reflect.Value构造后传入Call()方法中，调用完成时，函数的返回值通过[]reflect.Value返回。</p>
<p>下面的代码声明一个加法函数，传入两个整型值，返回两个整型值的和。</p>
<p>将函数保存到反射值对象（reflect.Value）中，然后将两个整型值构造为反射值对象的切片（[]reflect.Value），使用Call()方法进行调用。</p>
<div class="highlight-go notranslate"><div class="highlight"><pre><span></span><span class="kn">package</span> <span class="nx">main</span>

<span class="kn">import</span> <span class="p">(</span>
    <span class="s">&quot;fmt&quot;</span>
    <span class="s">&quot;reflect&quot;</span>
<span class="p">)</span>

<span class="c1">// 普通函数</span>
<span class="kd">func</span> <span class="nx">add</span><span class="p">(</span><span class="nx">a</span><span class="p">,</span><span class="nx">b</span> <span class="kt">int</span><span class="p">)</span> <span class="kt">int</span> <span class="p">{</span>
    <span class="k">return</span> <span class="nx">a</span><span class="o">+</span><span class="nx">b</span>
<span class="p">}</span>

<span class="kd">func</span> <span class="nx">main</span><span class="p">()</span> <span class="p">{</span>
    <span class="c1">// 将函数包装为反射值对象</span>
    <span class="nx">funcValue</span> <span class="o">:=</span> <span class="nx">reflect</span><span class="p">.</span><span class="nx">ValueOf</span><span class="p">(</span><span class="nx">add</span><span class="p">)</span>


    <span class="c1">// 构造函数参数，传入两个整型值</span>
    <span class="c1">// 将10和20两个整型值使用reflect.ValueOf包装为reflect.Value，再将反射值对象的切片[]reflect.Value作为函数的参数。</span>
    <span class="nx">paramList</span> <span class="o">:=</span> <span class="p">[]</span><span class="nx">reflect</span><span class="p">.</span><span class="nx">Value</span><span class="p">{</span><span class="nx">reflect</span><span class="p">.</span><span class="nx">ValueOf</span><span class="p">(</span><span class="mi">10</span><span class="p">),</span> <span class="nx">reflect</span><span class="p">.</span><span class="nx">ValueOf</span><span class="p">(</span><span class="mi">20</span><span class="p">)}</span>

    <span class="c1">// 反射调用函数</span>
    <span class="c1">// 使用funcValue函数值对象的Call()方法，传入参数列表paramList调用add()函数。</span>
    <span class="nx">retList</span> <span class="o">:=</span> <span class="nx">funcValue</span><span class="p">.</span><span class="nx">Call</span><span class="p">(</span><span class="nx">paramList</span><span class="p">)</span>

    <span class="c1">// 获取第一个返回值，取整数值</span>
    <span class="c1">// 调用成功后，通过retList[0]取返回值的第一个参数，使用Int取返回值的整数值。</span>
    <span class="nx">fmt</span><span class="p">.</span><span class="nx">Println</span><span class="p">(</span><span class="nx">retList</span><span class="p">[</span><span class="mi">0</span><span class="p">].</span><span class="nx">Int</span><span class="p">())</span>
<span class="p">}</span>
</pre></div>
</div>
<p><strong>提示：</strong></p>
<p>反射调用函数的过程需要构造大量的reflect.Value和中间变量，对函数参数值进行逐一检查，还需要将调用参数复制到调用函数的参数内存中。</p>
<p>调用完毕后，还需要将返回值转换为reflect.Value，用户还需要从中取出调用值。</p>
<p>因此，反射调用函数的性能问题尤为突出，不建议大量使用反射函数调用。</p>
</section>
</section>
<section id="json">
<h2><a class="toc-backref" href="#id44"><span class="section-number">9.1.4. </span>4 示例-将结构体的数据保存为JSON格式的文本数据</a><a class="headerlink" href="#json" title="Permalink to this headline">¶</a></h2>
<p>JSON格式是一种用途广泛的对象文本格式。在Go语言中，结构体可以通过系统提供的json.Marshal()函数进行序列化。为了演示怎样通过反射获取结构体成员及各种值的过程，下面使用反射将结构体序列化为文本数据。</p>
<section id="id26">
<h3><a class="toc-backref" href="#id45">4.1 自己动手实现</a><a class="headerlink" href="#id26" title="Permalink to this headline">¶</a></h3>
<section id="id27">
<h4>1 实现思路<a class="headerlink" href="#id27" title="Permalink to this headline">¶</a></h4>
<p>将结构体序列化为JSON的步骤如下：</p>
<p>（1）准备数据结构体。</p>
<p>（2）准备要序列化的结构体数据。</p>
<p>（3）调用序列化函数。</p>
<div class="highlight-go notranslate"><div class="highlight"><pre><span></span><span class="kn">package</span> <span class="nx">main</span>

<span class="kn">import</span> <span class="p">(</span>
    <span class="s">&quot;bytes&quot;</span>
    <span class="s">&quot;errors&quot;</span>
    <span class="s">&quot;fmt&quot;</span>
    <span class="s">&quot;reflect&quot;</span>
    <span class="s">&quot;strconv&quot;</span>
<span class="p">)</span>

<span class="c1">// MarshalJson 这个函数其实是对writeAny()函数的一个封装，将外部的interface{}类型转换为内部的reflect.Value类型，同时构建输出缓冲，将一些复杂的操作简化，方便外部使用。</span>
<span class="kd">func</span> <span class="nx">MarshalJson</span><span class="p">(</span><span class="nx">v</span> <span class="kd">interface</span><span class="p">{})</span> <span class="p">(</span><span class="kt">string</span><span class="p">,</span> <span class="kt">error</span><span class="p">)</span> <span class="p">{</span>
    <span class="c1">// 准备一个缓冲</span>
    <span class="c1">// 使用bytes.Buffer构建一个缓冲，这个对象类似于其他语言中的StringBuilder，在大量字符串连接时，推荐使用这个结构。</span>
    <span class="kd">var</span> <span class="nx">b</span> <span class="nx">bytes</span><span class="p">.</span><span class="nx">Buffer</span>

    <span class="c1">// 将任意值转换为JSON并输出到缓冲中</span>
    <span class="c1">// 调用writeAny()函数，将bytes.Buffer以指针的方式传入，以方便将各种类型的数据都写入这个bytes.Buffer中。</span>
    <span class="c1">// 同时，将v转换为反射值对象并传入。</span>
    <span class="k">if</span> <span class="nx">err</span> <span class="o">:=</span> <span class="nx">writeAny</span><span class="p">(</span><span class="o">&amp;</span><span class="nx">b</span><span class="p">,</span> <span class="nx">reflect</span><span class="p">.</span><span class="nx">ValueOf</span><span class="p">(</span><span class="nx">v</span><span class="p">));</span> <span class="nx">err</span> <span class="o">==</span> <span class="kc">nil</span> <span class="p">{</span>
        <span class="c1">// 如果没有错误发生时，将bytes.Buffer的内容转换为字符串并返回。</span>
        <span class="k">return</span> <span class="nx">b</span><span class="p">.</span><span class="nx">String</span><span class="p">(),</span> <span class="kc">nil</span>
    <span class="p">}</span><span class="k">else</span> <span class="p">{</span>
        <span class="c1">// 发生错误时，返回空字符串结果和错误</span>
        <span class="k">return</span> <span class="s">&quot;&quot;</span><span class="p">,</span> <span class="nx">err</span>
    <span class="p">}</span>

<span class="p">}</span>
<span class="kd">func</span> <span class="nx">writeAny</span><span class="p">(</span><span class="nx">buff</span> <span class="o">*</span><span class="nx">bytes</span><span class="p">.</span><span class="nx">Buffer</span><span class="p">,</span> <span class="nx">value</span> <span class="nx">reflect</span><span class="p">.</span><span class="nx">Value</span><span class="p">)</span> <span class="kt">error</span> <span class="p">{</span>
    <span class="c1">// 根据传入反射值对象的种类进行判断，如字符串、整型、切片及结构体。</span>
    <span class="k">switch</span> <span class="nx">value</span><span class="p">.</span><span class="nx">Kind</span><span class="p">()</span> <span class="p">{</span>
    <span class="k">case</span> <span class="nx">reflect</span><span class="p">.</span><span class="nx">String</span><span class="p">:</span>
        <span class="c1">// 写入带有双引号括起来的字符串</span>
        <span class="c1">// 使用reflect.Value的String函数将传入值转换为字符串，再将字符串用双引号括起来，strconv.Quote()函数提供了比较正规的封装。</span>
        <span class="c1">// 最终使用bytes.Buffer的WriteString()函数，将前面输出的字符串写入缓冲中。</span>
        <span class="nx">buff</span><span class="p">.</span><span class="nx">WriteString</span><span class="p">(</span><span class="nx">strconv</span><span class="p">.</span><span class="nx">Quote</span><span class="p">(</span><span class="nx">value</span><span class="p">.</span><span class="nx">String</span><span class="p">()))</span>
    <span class="k">case</span> <span class="nx">reflect</span><span class="p">.</span><span class="nx">Int</span><span class="p">:</span>
        <span class="c1">// 将整型转换为字符串并写入缓冲中</span>
        <span class="c1">// 当传入值为整型时，使用reflect.Value的Int()函数，将传入值转换为整型，</span>
        <span class="c1">// 再将整型以十进制格式使用strconv.FormatInt()函数格式化为字符串，最后写入缓冲中。</span>
        <span class="nx">buff</span><span class="p">.</span><span class="nx">WriteString</span><span class="p">(</span><span class="nx">strconv</span><span class="p">.</span><span class="nx">FormatInt</span><span class="p">(</span><span class="nx">value</span><span class="p">.</span><span class="nx">Int</span><span class="p">(),</span> <span class="mi">10</span><span class="p">))</span>
    <span class="k">case</span> <span class="nx">reflect</span><span class="p">.</span><span class="nx">Slice</span><span class="p">:</span>
        <span class="c1">// 使用writeSlice()函数把切片序列化为JSON操作。</span>
        <span class="k">return</span> <span class="nx">writeSlice</span><span class="p">(</span><span class="nx">buff</span><span class="p">,</span> <span class="nx">value</span><span class="p">)</span>
    <span class="k">case</span> <span class="nx">reflect</span><span class="p">.</span><span class="nx">Struct</span><span class="p">:</span>
        <span class="c1">// 使用writeStruct()函数把切片序列化为JSON操作。</span>
        <span class="k">return</span> <span class="nx">writeStruct</span><span class="p">(</span><span class="nx">buff</span><span class="p">,</span> <span class="nx">value</span><span class="p">)</span>
    <span class="k">default</span><span class="p">:</span>
        <span class="c1">// 遇到不认识的种类，返回错误</span>
        <span class="k">return</span> <span class="nx">errors</span><span class="p">.</span><span class="nx">New</span><span class="p">(</span><span class="s">&quot;unsupport kind: &quot;</span> <span class="o">+</span> <span class="nx">value</span><span class="p">.</span><span class="nx">Kind</span><span class="p">().</span><span class="nx">String</span><span class="p">())</span>
    <span class="p">}</span>
    <span class="k">return</span> <span class="kc">nil</span>
<span class="p">}</span>

<span class="c1">// 将切片转换为JSON格式并输出到缓冲中</span>
<span class="kd">func</span> <span class="nx">writeSlice</span><span class="p">(</span><span class="nx">buff</span> <span class="o">*</span><span class="nx">bytes</span><span class="p">.</span><span class="nx">Buffer</span><span class="p">,</span> <span class="nx">value</span> <span class="nx">reflect</span><span class="p">.</span><span class="nx">Value</span><span class="p">)</span> <span class="kt">error</span> <span class="p">{</span>
    <span class="c1">// 写入切片开始标记</span>
    <span class="nx">buff</span><span class="p">.</span><span class="nx">WriteString</span><span class="p">(</span><span class="s">&quot;[&quot;</span><span class="p">)</span>

    <span class="c1">// 遍历每个切片元素</span>
    <span class="k">for</span> <span class="nx">s</span> <span class="o">:=</span> <span class="mi">0</span><span class="p">;</span> <span class="nx">s</span> <span class="p">&lt;</span> <span class="nx">value</span><span class="p">.</span><span class="nx">Len</span><span class="p">();</span> <span class="nx">s</span><span class="o">++</span> <span class="p">{</span>
        <span class="nx">sliceValue</span> <span class="o">:=</span> <span class="nx">value</span><span class="p">.</span><span class="nx">Index</span><span class="p">(</span><span class="nx">s</span><span class="p">)</span>

        <span class="c1">// 写入每个切片元素</span>
        <span class="nx">writeAny</span><span class="p">(</span><span class="nx">buff</span><span class="p">,</span> <span class="nx">sliceValue</span><span class="p">)</span>

        <span class="c1">// 每个元素尾部写入逗号，最后一个字段不添加</span>
        <span class="k">if</span> <span class="nx">s</span> <span class="p">&lt;</span> <span class="nx">value</span><span class="p">.</span><span class="nx">Len</span><span class="p">()</span><span class="o">-</span><span class="mi">1</span> <span class="p">{</span>
            <span class="nx">buff</span><span class="p">.</span><span class="nx">WriteString</span><span class="p">(</span><span class="s">&quot;,&quot;</span><span class="p">)</span>
        <span class="p">}</span>
    <span class="p">}</span>
    <span class="c1">// 写入切片结束标记</span>
    <span class="nx">buff</span><span class="p">.</span><span class="nx">WriteString</span><span class="p">(</span><span class="s">&quot;]&quot;</span><span class="p">)</span>
    <span class="k">return</span> <span class="kc">nil</span>

<span class="p">}</span>

<span class="c1">// 将结构体序列化为JSON格式并输出到缓冲中</span>
<span class="kd">func</span> <span class="nx">writeStruct</span><span class="p">(</span><span class="nx">buff</span> <span class="o">*</span><span class="nx">bytes</span><span class="p">.</span><span class="nx">Buffer</span><span class="p">,</span> <span class="nx">value</span> <span class="nx">reflect</span><span class="p">.</span><span class="nx">Value</span><span class="p">)</span> <span class="kt">error</span> <span class="p">{</span>
    <span class="c1">// 取值的类型对象</span>
    <span class="c1">// 遍历结构体获取值时，习惯性取出反射类型对象。</span>
    <span class="nx">valueType</span> <span class="o">:=</span> <span class="nx">value</span><span class="p">.</span><span class="nx">Type</span><span class="p">()</span>

    <span class="c1">// 写入结构体左大括号</span>
    <span class="nx">buff</span><span class="p">.</span><span class="nx">WriteString</span><span class="p">(</span><span class="s">&quot;{&quot;</span><span class="p">)</span>

    <span class="c1">// 遍历结构体的所有值</span>
    <span class="c1">// 根据reflect.Value的NumField()方法遍历结构体的成员值。</span>
    <span class="k">for</span> <span class="nx">i</span> <span class="o">:=</span> <span class="mi">0</span><span class="p">;</span> <span class="nx">i</span> <span class="p">&lt;</span> <span class="nx">value</span><span class="p">.</span><span class="nx">NumField</span><span class="p">();</span> <span class="nx">i</span><span class="o">++</span> <span class="p">{</span>
        <span class="c1">// 获取每个字段的字段值(reflect.Value)</span>
        <span class="nx">fieldValue</span> <span class="o">:=</span> <span class="nx">value</span><span class="p">.</span><span class="nx">Field</span><span class="p">(</span><span class="nx">i</span><span class="p">)</span>

        <span class="c1">// 获取每个字段的类型(reflect.StructField)</span>
        <span class="c1">// 获取每一个结构体成员的反射值对象。</span>
        <span class="nx">fieldType</span> <span class="o">:=</span> <span class="nx">valueType</span><span class="p">.</span><span class="nx">Field</span><span class="p">(</span><span class="nx">i</span><span class="p">)</span>

        <span class="c1">// 写入字段名左双引号</span>
        <span class="nx">buff</span><span class="p">.</span><span class="nx">WriteString</span><span class="p">(</span><span class="s">&quot;\&quot;&quot;</span><span class="p">)</span>

        <span class="c1">// 写入字段名</span>
        <span class="nx">buff</span><span class="p">.</span><span class="nx">WriteString</span><span class="p">(</span><span class="nx">fieldType</span><span class="p">.</span><span class="nx">Name</span><span class="p">)</span>

        <span class="c1">// 写入字段名右双引号和冒号</span>
        <span class="nx">buff</span><span class="p">.</span><span class="nx">WriteString</span><span class="p">(</span><span class="s">&quot;\&quot;:&quot;</span><span class="p">)</span>

        <span class="c1">// 写入每个字段值</span>
        <span class="c1">// 递归调用任意值序列化函数writeAny()，将fieldValue继续序列化。</span>
        <span class="nx">writeAny</span><span class="p">(</span><span class="nx">buff</span><span class="p">,</span> <span class="nx">fieldValue</span><span class="p">)</span>

        <span class="c1">// 每个字段尾部写入逗号，最后一个字段不添加</span>
        <span class="k">if</span> <span class="nx">i</span> <span class="p">&lt;</span> <span class="nx">value</span><span class="p">.</span><span class="nx">NumField</span><span class="p">()</span><span class="o">-</span><span class="mi">1</span> <span class="p">{</span>
            <span class="nx">buff</span><span class="p">.</span><span class="nx">WriteString</span><span class="p">(</span><span class="s">&quot;,&quot;</span><span class="p">)</span>
        <span class="p">}</span>
    <span class="p">}</span>

    <span class="c1">// 写入结构体右大括号</span>
    <span class="nx">buff</span><span class="p">.</span><span class="nx">WriteString</span><span class="p">(</span><span class="s">&quot;}&quot;</span><span class="p">)</span>

    <span class="k">return</span> <span class="kc">nil</span>
<span class="p">}</span>

<span class="kd">func</span> <span class="nx">main</span><span class="p">()</span> <span class="p">{</span>
    <span class="c1">// 声明技能结构体</span>
    <span class="kd">type</span> <span class="nx">Skill</span> <span class="kd">struct</span> <span class="p">{</span>
        <span class="nx">Name</span>  <span class="kt">string</span>
        <span class="nx">Level</span> <span class="kt">int</span>
    <span class="p">}</span>
    <span class="c1">// 声明角色结构体</span>
    <span class="kd">type</span> <span class="nx">Actor</span> <span class="kd">struct</span> <span class="p">{</span>
        <span class="nx">Name</span>   <span class="kt">string</span>
        <span class="nx">Age</span>    <span class="kt">int</span>
        <span class="nx">Skills</span> <span class="p">[]</span><span class="nx">Skill</span>
    <span class="p">}</span>
    <span class="c1">// 填充基本角色数据</span>
    <span class="nx">a</span> <span class="o">:=</span> <span class="nx">Actor</span><span class="p">{</span>
        <span class="nx">Name</span><span class="p">:</span> <span class="s">&quot;cow boy&quot;</span><span class="p">,</span>
        <span class="nx">Age</span><span class="p">:</span>  <span class="mi">37</span><span class="p">,</span>
        <span class="nx">Skills</span><span class="p">:</span> <span class="p">[]</span><span class="nx">Skill</span><span class="p">{</span>
            <span class="p">{</span><span class="nx">Name</span><span class="p">:</span> <span class="s">&quot;Roll and roll&quot;</span><span class="p">,</span> <span class="nx">Level</span><span class="p">:</span> <span class="mi">1</span><span class="p">},</span>
            <span class="p">{</span><span class="nx">Name</span><span class="p">:</span> <span class="s">&quot;Flash your dog eye&quot;</span><span class="p">,</span> <span class="nx">Level</span><span class="p">:</span> <span class="mi">2</span><span class="p">},</span>
            <span class="p">{</span><span class="nx">Name</span><span class="p">:</span> <span class="s">&quot;Time to have Lunch&quot;</span><span class="p">,</span> <span class="nx">Level</span><span class="p">:</span> <span class="mi">3</span><span class="p">},</span>
        <span class="p">},</span>
    <span class="p">}</span>
    <span class="c1">// 调用自己实现的MarshalJson()函数，将Actor实例化的数据转换为JSON字符串。</span>
    <span class="k">if</span> <span class="nx">result</span><span class="p">,</span> <span class="nx">err</span> <span class="o">:=</span> <span class="nx">MarshalJson</span><span class="p">(</span><span class="nx">a</span><span class="p">);</span> <span class="nx">err</span> <span class="o">==</span> <span class="kc">nil</span> <span class="p">{</span>
        <span class="nx">fmt</span><span class="p">.</span><span class="nx">Println</span><span class="p">(</span><span class="nx">result</span><span class="p">)</span>
    <span class="p">}</span><span class="k">else</span> <span class="p">{</span>
        <span class="nx">fmt</span><span class="p">.</span><span class="nx">Println</span><span class="p">(</span><span class="nx">err</span><span class="p">)</span>
    <span class="p">}</span>
<span class="p">}</span>
</pre></div>
</div>
</section>
<section id="id28">
<h4>2 总结<a class="headerlink" href="#id28" title="Permalink to this headline">¶</a></h4>
<p>上面例子只支持整型、字符串、切片和结构体类型序列化为JSON格式。</p>
<p>如果需要扩充类型，可以在writeAny()函数中添加。程序功能和结构上还有一些不足，例如：</p>
<ul class="simple">
<li><p>没有处理各种异常情况，切片或结构体为空时应该提前判断，否则会触发宕机。</p></li>
<li><p>可以支持结构体标签（Struct
Tag），方便自定义JSON的键名及忽略某些字段的序列化过程，避免这些字段被序列化到JSON中。</p></li>
<li><p>支持缩进且可以自定义缩进字符，将JSON序列化后的内容格式化，方便查看。</p></li>
<li><p>默认应该序列化为[]byte字节数组，外部自己转换为字符串。在大部分的使用中，JSON一般以字节数组方式解析、存储、传输，很少以字符串方式解析，因此避免字节数组和字符串的转换可以提高一些性能。</p></li>
</ul>
</section>
</section>
<section id="encoding-json">
<h3><a class="toc-backref" href="#id46">4.2 使用encoding/json包</a><a class="headerlink" href="#encoding-json" title="Permalink to this headline">¶</a></h3>
<div class="highlight-go notranslate"><div class="highlight"><pre><span></span><span class="kn">package</span> <span class="nx">main</span>

<span class="kn">import</span> <span class="p">(</span>
   <span class="s">&quot;encoding/json&quot;</span>
   <span class="s">&quot;fmt&quot;</span>
<span class="p">)</span>
<span class="kd">func</span> <span class="nx">main</span><span class="p">()</span> <span class="p">{</span>
   <span class="c1">// 声明技能结构体</span>
   <span class="kd">type</span> <span class="nx">Skill</span> <span class="kd">struct</span> <span class="p">{</span>
       <span class="nx">Name</span>  <span class="kt">string</span>
       <span class="nx">Level</span> <span class="kt">int</span>
   <span class="p">}</span>
   <span class="c1">// 声明角色结构体</span>
   <span class="kd">type</span> <span class="nx">Actor</span> <span class="kd">struct</span> <span class="p">{</span>
       <span class="nx">Name</span>   <span class="kt">string</span>
       <span class="nx">Age</span>    <span class="kt">int</span>
       <span class="nx">Skills</span> <span class="p">[]</span><span class="nx">Skill</span>
   <span class="p">}</span>
   <span class="c1">// 填充基本角色数据</span>
   <span class="nx">a</span> <span class="o">:=</span> <span class="nx">Actor</span><span class="p">{</span>
       <span class="nx">Name</span><span class="p">:</span> <span class="s">&quot;cow boy&quot;</span><span class="p">,</span>
       <span class="nx">Age</span><span class="p">:</span>  <span class="mi">37</span><span class="p">,</span>
       <span class="nx">Skills</span><span class="p">:</span> <span class="p">[]</span><span class="nx">Skill</span><span class="p">{</span>
           <span class="p">{</span><span class="nx">Name</span><span class="p">:</span> <span class="s">&quot;Roll and roll&quot;</span><span class="p">,</span> <span class="nx">Level</span><span class="p">:</span> <span class="mi">1</span><span class="p">},</span>
           <span class="p">{</span><span class="nx">Name</span><span class="p">:</span> <span class="s">&quot;Flash your dog eye&quot;</span><span class="p">,</span> <span class="nx">Level</span><span class="p">:</span> <span class="mi">2</span><span class="p">},</span>
           <span class="p">{</span><span class="nx">Name</span><span class="p">:</span> <span class="s">&quot;Time to have Lunch&quot;</span><span class="p">,</span> <span class="nx">Level</span><span class="p">:</span> <span class="mi">3</span><span class="p">},</span>
       <span class="p">},</span>
   <span class="p">}</span>
   <span class="nx">result</span><span class="p">,</span> <span class="nx">err</span> <span class="o">:=</span> <span class="nx">json</span><span class="p">.</span><span class="nx">MarshalIndent</span><span class="p">(</span><span class="nx">a</span><span class="p">,</span> <span class="s">&quot;&quot;</span><span class="p">,</span> <span class="s">&quot;\t&quot;</span><span class="p">)</span>
   <span class="k">if</span> <span class="nx">err</span> <span class="o">!=</span> <span class="kc">nil</span> <span class="p">{</span>
       <span class="nx">fmt</span><span class="p">.</span><span class="nx">Println</span><span class="p">(</span><span class="nx">err</span><span class="p">)</span>
   <span class="p">}</span>
   <span class="nx">jsonStringData</span> <span class="o">:=</span> <span class="nb">string</span><span class="p">(</span><span class="nx">result</span><span class="p">)</span>
   <span class="nx">fmt</span><span class="p">.</span><span class="nx">Println</span><span class="p">(</span><span class="nx">jsonStringData</span><span class="p">)</span>
<span class="p">}</span>
</pre></div>
</div>
</section>
</section>
</section>


           </div>
          </div>
          <footer><div class="rst-footer-buttons" role="navigation" aria-label="Footer">
        <a href="index.html" class="btn btn-neutral float-left" title="9. 反射" accesskey="p" rel="prev"><span class="fa fa-arrow-circle-left" aria-hidden="true"></span> Previous</a>
        <a href="../10.%E6%A0%87%E5%87%86%E5%BA%93%E5%92%8C%E4%B8%89%E6%96%B9%E5%BA%93/index.html" class="btn btn-neutral float-right" title="10. 标准库和三方库" accesskey="n" rel="next">Next <span class="fa fa-arrow-circle-right" aria-hidden="true"></span></a>
    </div>

  <hr/>

  <div role="contentinfo">
    <p>&#169; Copyright 2019, huxiaojian.</p>
  </div>

  Built with <a href="https://www.sphinx-doc.org/">Sphinx</a> using a
    <a href="https://github.com/readthedocs/sphinx_rtd_theme">theme</a>
    provided by <a href="https://readthedocs.org">Read the Docs</a>.
   

</footer>
        </div>
      </div>
    </section>
  </div>
  <script>
      jQuery(function () {
          SphinxRtdTheme.Navigation.enable(true);
      });
  </script> 

</body>
</html>