<!DOCTYPE html>
<html class="writer-html5" lang="en" >
<head>
  <meta charset="utf-8" /><meta name="generator" content="Docutils 0.17: http://docutils.sourceforge.net/" />

  <meta name="viewport" content="width=device-width, initial-scale=1.0" />
  <title>12.1. 合理地使用并发特性 &mdash; 运维开发修炼之路</title>
      <link rel="stylesheet" href="../../_static/pygments.css" type="text/css" />
      <link rel="stylesheet" href="../../_static/css/theme.css" type="text/css" />
  <!--[if lt IE 9]>
    <script src="../../_static/js/html5shiv.min.js"></script>
  <![endif]-->
  
        <script data-url_root="../../" id="documentation_options" src="../../_static/documentation_options.js"></script>
        <script src="../../_static/jquery.js"></script>
        <script src="../../_static/underscore.js"></script>
        <script src="../../_static/doctools.js"></script>
    <script src="../../_static/js/theme.js"></script>
    <link rel="index" title="Index" href="../../genindex.html" />
    <link rel="search" title="Search" href="../../search.html" />
    <link rel="next" title="Go vs Python" href="../../Go_vs_Python/index.html" />
    <link rel="prev" title="12. 避坑与技巧" href="index.html" /> 
</head>

<body class="wy-body-for-nav"> 
  <div class="wy-grid-for-nav">
    <nav data-toggle="wy-nav-shift" class="wy-nav-side">
      <div class="wy-side-scroll">
        <div class="wy-side-nav-search" >
            <a href="../../index.html" class="icon icon-home"> 小健_Python_go_Devops
            <img src="../../_static/python_go.png" class="logo" alt="Logo"/>
          </a>
              <div class="version">
                2.0
              </div>
<div role="search">
  <form id="rtd-search-form" class="wy-form" action="../../search.html" method="get">
    <input type="text" name="q" placeholder="Search docs" />
    <input type="hidden" name="check_keywords" value="yes" />
    <input type="hidden" name="area" value="default" />
  </form>
</div>
        </div><div class="wy-menu wy-menu-vertical" data-spy="affix" role="navigation" aria-label="Navigation menu">
              <ul class="current">
<li class="toctree-l1 current"><a class="reference internal" href="../index.html">Go语言学习</a><ul class="current">
<li class="toctree-l2"><a class="reference internal" href="../01.Go%E8%AF%AD%E8%A8%80%E5%9F%BA%E6%9C%AC%E8%AF%AD%E6%B3%95/index.html">1. Go语言基本语法</a></li>
<li class="toctree-l2"><a class="reference internal" href="../02.%E5%AE%B9%E5%99%A8-%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/index.html">2. 容器-数据结构</a></li>
<li class="toctree-l2"><a class="reference internal" href="../03.%E6%B5%81%E7%A8%8B%E6%8E%A7%E5%88%B6/index.html">3. 流程控制</a></li>
<li class="toctree-l2"><a class="reference internal" href="../04.%E5%87%BD%E6%95%B0/index.html">4. 函数</a></li>
<li class="toctree-l2"><a class="reference internal" href="../05.%E7%BB%93%E6%9E%84%E4%BD%93/index.html">5. 结构体</a></li>
<li class="toctree-l2"><a class="reference internal" href="../06.%E6%8E%A5%E5%8F%A3/index.html">6. 接口</a></li>
<li class="toctree-l2"><a class="reference internal" href="../07.%E5%8C%85/index.html">7. 包</a></li>
<li class="toctree-l2"><a class="reference internal" href="../08.%E5%B9%B6%E5%8F%91/index.html">8. 并发</a></li>
<li class="toctree-l2"><a class="reference internal" href="../09.%E5%8F%8D%E5%B0%84/index.html">9. 反射</a></li>
<li class="toctree-l2"><a class="reference internal" href="../10.%E6%A0%87%E5%87%86%E5%BA%93%E5%92%8C%E4%B8%89%E6%96%B9%E5%BA%93/index.html">10. 标准库和三方库</a></li>
<li class="toctree-l2"><a class="reference internal" href="../11.%E9%A1%B9%E7%9B%AE%E4%BB%A3%E7%A0%81/index.html">11. 项目代码</a></li>
<li class="toctree-l2 current"><a class="reference internal" href="index.html">12. 避坑与技巧</a><ul class="current">
<li class="toctree-l3 current"><a class="current reference internal" href="#">12.1. 合理地使用并发特性</a><ul>
<li class="toctree-l4"><a class="reference internal" href="#goroutinegoroutine">12.1.1. 1.了解goroutine的生命期时再创建goroutine</a></li>
<li class="toctree-l4"><a class="reference internal" href="#id2">12.1.2. 2.避免在不必要的地方使用通道</a></li>
<li class="toctree-l4"><a class="reference internal" href="#id4">12.1.3. 3.反射:性能和灵活性的双刃剑</a></li>
<li class="toctree-l4"><a class="reference internal" href="#nil">12.1.4. 4.接口的nil判断</a></li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
<li class="toctree-l1"><a class="reference internal" href="../../Go_vs_Python/index.html">Go vs Python</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../Python/index.html">Python全栈系列</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../Python%E6%B5%8B%E8%AF%95%E5%BC%80%E5%8F%91%E5%85%A5%E9%97%A8%E4%B8%8E%E5%AE%9E%E8%B7%B5/index.html">Python测试开发入门与实践</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../Vue/index.html">Vue.js企业开发实战</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../Vue_Node.js/index.html">Vue.js+Node.js开发实战</a></li>
</ul>

        </div>
      </div>
    </nav>

    <section data-toggle="wy-nav-shift" class="wy-nav-content-wrap"><nav class="wy-nav-top" aria-label="Mobile navigation menu" >
          <i data-toggle="wy-nav-top" class="fa fa-bars"></i>
          <a href="../../index.html">小健_Python_go_Devops</a>
      </nav>

      <div class="wy-nav-content">
        <div class="rst-content">
          <div role="navigation" aria-label="Page navigation">
  <ul class="wy-breadcrumbs">
      <li><a href="../../index.html" class="icon icon-home"></a> &raquo;</li>
          <li><a href="../index.html">Go语言学习</a> &raquo;</li>
          <li><a href="index.html"><span class="section-number">12. </span>避坑与技巧</a> &raquo;</li>
      <li><span class="section-number">12.1. </span>合理地使用并发特性</li>
      <li class="wy-breadcrumbs-aside">
            <a href="../../_sources/Go/12.避坑与技巧/01.合理地使用并发特性.rst.txt" rel="nofollow"> View page source</a>
      </li>
  </ul>
  <hr/>
</div>
          <div role="main" class="document" itemscope="itemscope" itemtype="http://schema.org/Article">
           <div itemprop="articleBody">
             
  <div class="contents topic" id="contents">
<p class="topic-title">Contents</p>
<ul class="simple">
<li><p><a class="reference internal" href="#id1" id="id8">合理地使用并发特性</a></p>
<ul>
<li><p><a class="reference internal" href="#goroutinegoroutine" id="id9">1.了解goroutine的生命期时再创建goroutine</a></p></li>
<li><p><a class="reference internal" href="#id2" id="id10">2.避免在不必要的地方使用通道</a></p>
<ul>
<li><p><a class="reference internal" href="#goroutine" id="id11">2.1 连接、关闭、同步goroutine</a></p></li>
<li><p><a class="reference internal" href="#id3" id="id12">2.2 优化：使用等待组替代通道简化同步</a></p></li>
</ul>
</li>
<li><p><a class="reference internal" href="#id4" id="id13">3.反射:性能和灵活性的双刃剑</a></p>
<ul>
<li><p><a class="reference internal" href="#id5" id="id14">3.1 结构体成员赋值对比</a></p></li>
<li><p><a class="reference internal" href="#id6" id="id15">3.2 基准测试结果对比</a></p></li>
</ul>
</li>
<li><p><a class="reference internal" href="#nil" id="id16">4.接口的nil判断</a></p>
<ul>
<li><p><a class="reference internal" href="#id7" id="id17">4.1 接口与nil不相等</a></p></li>
</ul>
</li>
</ul>
</li>
</ul>
</div>
<section id="id1">
<h1><a class="toc-backref" href="#id8"><span class="section-number">12.1. </span>合理地使用并发特性</a><a class="headerlink" href="#id1" title="Permalink to this headline">¶</a></h1>
<p>Go语言原生支持并发是被众人津津乐道的特性。goroutine早期是Inferno操作系统的一个试验性特性，而现在这个特性与操作系统一起，将开发变得越来越简单。</p>
<p>很多刚开始使用Go语言开发的人都很喜欢使用并发特性，而没有考虑并发是否真正能解决他们的问题。</p>
<section id="goroutinegoroutine">
<h2><a class="toc-backref" href="#id9"><span class="section-number">12.1.1. </span>1.了解goroutine的生命期时再创建goroutine</a><a class="headerlink" href="#goroutinegoroutine" title="Permalink to this headline">¶</a></h2>
<p>在Go语言中，开发者习惯将并发内容与goroutine一一对应地创建goroutine。</p>
<p>开发者很少会考虑goroutine在什么时候能退出和控制goroutine生命期，这就会造成goroutine失控的情况。下面来看一段代码。</p>
<div class="highlight-go notranslate"><div class="highlight"><pre><span></span><span class="kn">package</span> <span class="nx">main</span>

<span class="kn">import</span> <span class="p">(</span>
    <span class="s">&quot;fmt&quot;</span>
    <span class="s">&quot;runtime&quot;</span>
<span class="p">)</span>

<span class="kd">func</span> <span class="nx">consumer</span><span class="p">(</span><span class="nx">ch</span> <span class="kd">chan</span> <span class="kt">int</span><span class="p">)</span> <span class="p">{</span>
    <span class="c1">// 无限获取数据的循环</span>
    <span class="k">for</span>  <span class="p">{</span>
        <span class="c1">// 从通道获取数据</span>
        <span class="nx">data</span> <span class="o">:=</span> <span class="o">&lt;-</span><span class="nx">ch</span>
        <span class="nx">fmt</span><span class="p">.</span><span class="nx">Println</span><span class="p">(</span><span class="nx">data</span><span class="p">)</span>
    <span class="p">}</span>

<span class="p">}</span>

<span class="kd">func</span> <span class="nx">main</span><span class="p">()</span> <span class="p">{</span>
    <span class="nx">ch</span> <span class="o">:=</span> <span class="nb">make</span><span class="p">(</span><span class="kd">chan</span> <span class="kt">int</span><span class="p">)</span>
    <span class="k">for</span>  <span class="p">{</span>
        <span class="c1">// 空变量，什么也不做</span>
        <span class="kd">var</span> <span class="nx">dummy</span> <span class="kt">string</span>
        <span class="c1">// 获取输入，模拟进程持续运行</span>
        <span class="nx">fmt</span><span class="p">.</span><span class="nx">Scan</span><span class="p">(</span><span class="o">&amp;</span><span class="nx">dummy</span><span class="p">)</span>

        <span class="c1">// 启动并发执行consumer()函数</span>
        <span class="k">go</span> <span class="nx">consumer</span><span class="p">(</span><span class="nx">ch</span><span class="p">)</span>
        <span class="c1">// 输出现在的goroutine数量</span>
        <span class="nx">fmt</span><span class="p">.</span><span class="nx">Println</span><span class="p">(</span><span class="s">&quot;goroutines:&quot;</span><span class="p">,</span> <span class="nx">runtime</span><span class="p">.</span><span class="nx">NumGoroutine</span><span class="p">())</span>
    <span class="p">}</span>
<span class="p">}</span>
</pre></div>
</div>
<p>运行程序，每输入一个字符串+回车，将会创建一个goroutine，结果如下：</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">a</span>
<span class="n">goroutines</span><span class="p">:</span> <span class="mi">2</span>
<span class="n">b</span>
<span class="n">goroutines</span><span class="p">:</span> <span class="mi">3</span>
<span class="n">c</span>
<span class="n">goroutines</span><span class="p">:</span> <span class="mi">4</span>
</pre></div>
</div>
<p>这个程序实际在模拟一个进程根据需要创建goroutine的情况。运行后，问题已经被暴露出来：随着输入的字符串越来越多，goroutine将会无限制地被创建，但并不会结束。</p>
<p>这种情况如果发生在生产环境中，将会造成内存大量分配，最终使进程崩溃。现实的情况也许比这段代码更加隐蔽：也许你设置了一个退出的条件，但是条件永远不会被满足或者触发。</p>
<p>为了避免这种情况，在这个例子中，需要为consumer()函数添加合理的退出条件，修改代码后如下：</p>
<div class="highlight-go notranslate"><div class="highlight"><pre><span></span><span class="kn">package</span> <span class="nx">main</span>

<span class="kn">import</span> <span class="p">(</span>
    <span class="s">&quot;fmt&quot;</span>
    <span class="s">&quot;runtime&quot;</span>
<span class="p">)</span>

<span class="kd">func</span> <span class="nx">consumer</span><span class="p">(</span><span class="nx">ch</span> <span class="kd">chan</span> <span class="kt">int</span><span class="p">)</span> <span class="p">{</span>
    <span class="c1">// 无限获取数据的循环</span>
    <span class="k">for</span>  <span class="p">{</span>
        <span class="c1">// 从通道获取数据</span>
        <span class="nx">data</span> <span class="o">:=</span> <span class="o">&lt;-</span><span class="nx">ch</span>
        <span class="k">if</span> <span class="nx">data</span> <span class="o">==</span> <span class="mi">0</span><span class="p">{</span>
            <span class="k">break</span>
        <span class="p">}</span>
        <span class="nx">fmt</span><span class="p">.</span><span class="nx">Println</span><span class="p">(</span><span class="nx">data</span><span class="p">)</span>
    <span class="p">}</span>
    <span class="nx">fmt</span><span class="p">.</span><span class="nx">Println</span><span class="p">(</span><span class="s">&quot;goroutine exit&quot;</span><span class="p">)</span>
<span class="p">}</span>

<span class="kd">func</span> <span class="nx">main</span><span class="p">()</span> <span class="p">{</span>
    <span class="nx">ch</span> <span class="o">:=</span> <span class="nb">make</span><span class="p">(</span><span class="kd">chan</span> <span class="kt">int</span><span class="p">)</span>
    <span class="k">for</span>  <span class="p">{</span>
        <span class="c1">// 空变量，什么也不做</span>
        <span class="kd">var</span> <span class="nx">dummy</span> <span class="kt">string</span>
        <span class="c1">// 获取输入，模拟进程持续运行</span>
        <span class="nx">fmt</span><span class="p">.</span><span class="nx">Scan</span><span class="p">(</span><span class="o">&amp;</span><span class="nx">dummy</span><span class="p">)</span>
        <span class="c1">// 当命令行输入quit时，进入退出处理的流程。</span>
        <span class="k">if</span> <span class="nx">dummy</span> <span class="o">==</span> <span class="s">&quot;quit&quot;</span> <span class="p">{</span>
            <span class="c1">// runtime.NumGoroutine返回一个进程的所有goroutine数，main()的goroutine也被算在里面。</span>
            <span class="c1">// 因此需要扣除main()的goroutine数。剩下的goroutine为实际创建的goroutine数，对这些goroutine进行遍历。</span>
            <span class="k">for</span> <span class="nx">i</span> <span class="o">:=</span> <span class="mi">0</span><span class="p">;</span> <span class="nx">i</span> <span class="p">&lt;</span> <span class="nx">runtime</span><span class="p">.</span><span class="nx">NumGoroutine</span><span class="p">()</span><span class="o">-</span><span class="mi">1</span><span class="p">;</span> <span class="nx">i</span><span class="o">++</span> <span class="p">{</span>
                <span class="c1">// 并发开启的goroutine都在竞争获取通道中的数据，因此只要知道有多少个goroutine需要退出，就给通道里发多少个0。</span>
                <span class="nx">ch</span> <span class="o">&lt;-</span> <span class="mi">0</span>
            <span class="p">}</span>
            <span class="k">continue</span>
        <span class="p">}</span>
        <span class="c1">// 启动并发执行consumer()函数</span>
        <span class="k">go</span> <span class="nx">consumer</span><span class="p">(</span><span class="nx">ch</span><span class="p">)</span>
        <span class="c1">// 输出现在的goroutine数量</span>
        <span class="c1">// 每启动一个goroutine，使用runtime.NumGoroutine检查进程创建的goroutine数量总数。</span>
        <span class="nx">fmt</span><span class="p">.</span><span class="nx">Println</span><span class="p">(</span><span class="s">&quot;goroutines:&quot;</span><span class="p">,</span> <span class="nx">runtime</span><span class="p">.</span><span class="nx">NumGoroutine</span><span class="p">())</span>
    <span class="p">}</span>
<span class="p">}</span>
</pre></div>
</div>
</section>
<section id="id2">
<h2><a class="toc-backref" href="#id10"><span class="section-number">12.1.2. </span>2.避免在不必要的地方使用通道</a><a class="headerlink" href="#id2" title="Permalink to this headline">¶</a></h2>
<p>通道（channel）和map、切片一样，也是由Go源码编写而成。为了保证两个goroutine并发访问的安全性，通道也需要做一些锁操作，因此通道其实并不比锁高效。</p>
<p>下面的例子展示套接字的接收和并发管理。对于TCP来说，一般是接收过程创建goroutine并发处理。当套接字结束时，就要正常退出这些goroutine。</p>
<section id="goroutine">
<h3><a class="toc-backref" href="#id11">2.1 连接、关闭、同步goroutine</a><a class="headerlink" href="#goroutine" title="Permalink to this headline">¶</a></h3>
<div class="highlight-go notranslate"><div class="highlight"><pre><span></span><span class="kn">package</span> <span class="nx">main</span>

<span class="kn">import</span> <span class="p">(</span>
    <span class="s">&quot;fmt&quot;</span>
    <span class="s">&quot;net&quot;</span>
    <span class="s">&quot;time&quot;</span>
<span class="p">)</span>

<span class="kd">func</span> <span class="nx">socketRecv</span><span class="p">(</span><span class="nx">conn</span> <span class="nx">net</span><span class="p">.</span><span class="nx">Conn</span><span class="p">,</span> <span class="nx">exitChan</span> <span class="kd">chan</span> <span class="kt">string</span><span class="p">)</span> <span class="p">{</span>
    <span class="c1">// 创建一个接收的缓冲</span>
    <span class="nx">buff</span> <span class="o">:=</span> <span class="nb">make</span><span class="p">([]</span><span class="kt">byte</span><span class="p">,</span> <span class="mi">1024</span><span class="p">)</span>
    <span class="c1">// 不停地接收数据</span>
    <span class="k">for</span>  <span class="p">{</span>
        <span class="c1">// 从套接字中读取数据</span>
        <span class="nx">_</span><span class="p">,</span> <span class="nx">err</span> <span class="o">:=</span> <span class="nx">conn</span><span class="p">.</span><span class="nx">Read</span><span class="p">(</span><span class="nx">buff</span><span class="p">)</span>
        <span class="c1">// 需要结束接收，退出循环</span>
        <span class="k">if</span> <span class="nx">err</span> <span class="o">!=</span> <span class="kc">nil</span> <span class="p">{</span>
            <span class="k">break</span>
        <span class="p">}</span>
    <span class="p">}</span>
    <span class="c1">// 函数已经结束，发送通知</span>
    <span class="nx">exitChan</span> <span class="o">&lt;-</span> <span class="s">&quot;recv exit&quot;</span>
<span class="p">}</span>
<span class="kd">func</span> <span class="nx">main</span><span class="p">()</span> <span class="p">{</span>
    <span class="c1">// 连接一个地址</span>
    <span class="nx">conn</span><span class="p">,</span> <span class="nx">err</span> <span class="o">:=</span> <span class="nx">net</span><span class="p">.</span><span class="nx">Dial</span><span class="p">(</span><span class="s">&quot;tcp&quot;</span><span class="p">,</span> <span class="s">&quot;www.163.com:80&quot;</span><span class="p">)</span>
    <span class="c1">// 发生错误时打印错误退出</span>
    <span class="k">if</span> <span class="nx">err</span> <span class="o">!=</span> <span class="kc">nil</span> <span class="p">{</span>
        <span class="nx">fmt</span><span class="p">.</span><span class="nx">Println</span><span class="p">(</span><span class="nx">err</span><span class="p">)</span>
        <span class="k">return</span>
    <span class="p">}</span>
    <span class="c1">// 创建退出通道</span>
    <span class="nx">exit</span> <span class="o">:=</span> <span class="nb">make</span><span class="p">(</span><span class="kd">chan</span> <span class="kt">string</span><span class="p">)</span>
    <span class="c1">// 并发执行套接字接收</span>
    <span class="k">go</span> <span class="nx">socketRecv</span><span class="p">(</span><span class="nx">conn</span><span class="p">,</span> <span class="nx">exit</span><span class="p">)</span>
    <span class="c1">// 在接收时，等待1秒</span>
    <span class="nx">time</span><span class="p">.</span><span class="nx">Sleep</span><span class="p">(</span><span class="nx">time</span><span class="p">.</span><span class="nx">Second</span><span class="p">)</span>
    <span class="c1">// 主动关闭套接字</span>
    <span class="nx">conn</span><span class="p">.</span><span class="nx">Close</span><span class="p">()</span>

    <span class="c1">// 等待goroutine退出完毕</span>
    <span class="nx">fmt</span><span class="p">.</span><span class="nx">Println</span><span class="p">(</span><span class="o">&lt;-</span><span class="nx">exit</span><span class="p">)</span>

<span class="p">}</span>
</pre></div>
</div>
<p>在这个例子中，goroutine退出使用通道来通知，这种做法可以解决问题，但是实际上通道中的数据并没有完全使用。</p>
</section>
<section id="id3">
<h3><a class="toc-backref" href="#id12">2.2 优化：使用等待组替代通道简化同步</a><a class="headerlink" href="#id3" title="Permalink to this headline">¶</a></h3>
<div class="highlight-go notranslate"><div class="highlight"><pre><span></span><span class="kn">package</span> <span class="nx">main</span>

<span class="kn">import</span> <span class="p">(</span>
    <span class="s">&quot;fmt&quot;</span>
    <span class="s">&quot;net&quot;</span>
    <span class="s">&quot;sync&quot;</span>
    <span class="s">&quot;time&quot;</span>
<span class="p">)</span>

<span class="kd">func</span> <span class="nx">socketRecv</span><span class="p">(</span><span class="nx">conn</span> <span class="nx">net</span><span class="p">.</span><span class="nx">Conn</span><span class="p">,</span>  <span class="nx">wg</span> <span class="o">*</span><span class="nx">sync</span><span class="p">.</span><span class="nx">WaitGroup</span><span class="p">)</span> <span class="p">{</span>
    <span class="c1">// 创建一个接收的缓冲</span>
    <span class="nx">buff</span> <span class="o">:=</span> <span class="nb">make</span><span class="p">([]</span><span class="kt">byte</span><span class="p">,</span> <span class="mi">1024</span><span class="p">)</span>
    <span class="c1">// 不停地接收数据</span>
    <span class="k">for</span>  <span class="p">{</span>
        <span class="c1">// 从套接字中读取数据</span>
        <span class="nx">_</span><span class="p">,</span> <span class="nx">err</span> <span class="o">:=</span> <span class="nx">conn</span><span class="p">.</span><span class="nx">Read</span><span class="p">(</span><span class="nx">buff</span><span class="p">)</span>
        <span class="c1">// 需要结束接收，退出循环</span>
        <span class="k">if</span> <span class="nx">err</span> <span class="o">!=</span> <span class="kc">nil</span> <span class="p">{</span>
            <span class="k">break</span>
        <span class="p">}</span>
    <span class="p">}</span>
    <span class="c1">// 接收完成后，使用wg.Done()方法将等待组计数器减一。</span>
    <span class="nx">wg</span><span class="p">.</span><span class="nx">Done</span><span class="p">()</span>
<span class="p">}</span>
<span class="kd">func</span> <span class="nx">main</span><span class="p">()</span> <span class="p">{</span>
    <span class="c1">// 连接一个地址</span>
    <span class="nx">conn</span><span class="p">,</span> <span class="nx">err</span> <span class="o">:=</span> <span class="nx">net</span><span class="p">.</span><span class="nx">Dial</span><span class="p">(</span><span class="s">&quot;tcp&quot;</span><span class="p">,</span> <span class="s">&quot;www.163.com:80&quot;</span><span class="p">)</span>
    <span class="c1">// 发生错误时打印错误退出</span>
    <span class="k">if</span> <span class="nx">err</span> <span class="o">!=</span> <span class="kc">nil</span> <span class="p">{</span>
        <span class="nx">fmt</span><span class="p">.</span><span class="nx">Println</span><span class="p">(</span><span class="nx">err</span><span class="p">)</span>
        <span class="k">return</span>
    <span class="p">}</span>

    <span class="c1">// 退出通道</span>
    <span class="kd">var</span> <span class="nx">wg</span> <span class="nx">sync</span><span class="p">.</span><span class="nx">WaitGroup</span>
    <span class="c1">// 为等待组的计数器加1，表示需要完成一个任务。</span>
    <span class="nx">wg</span><span class="p">.</span><span class="nx">Add</span><span class="p">(</span><span class="mi">1</span><span class="p">)</span>

    <span class="c1">// 将等待组的指针传入接收函数。</span>
    <span class="k">go</span> <span class="nx">socketRecv</span><span class="p">(</span><span class="nx">conn</span><span class="p">,</span> <span class="o">&amp;</span><span class="nx">wg</span><span class="p">)</span>
    <span class="nx">time</span><span class="p">.</span><span class="nx">Sleep</span><span class="p">(</span><span class="nx">time</span><span class="p">.</span><span class="nx">Second</span><span class="p">)</span>
    <span class="nx">conn</span><span class="p">.</span><span class="nx">Close</span><span class="p">()</span>

    <span class="c1">// 等待等待组的完成，完成后打印提示。</span>
    <span class="nx">wg</span><span class="p">.</span><span class="nx">Wait</span><span class="p">()</span>
    <span class="nx">fmt</span><span class="p">.</span><span class="nx">Println</span><span class="p">(</span><span class="s">&quot;recv done&quot;</span><span class="p">)</span>

<span class="p">}</span>
</pre></div>
</div>
</section>
</section>
<section id="id4">
<h2><a class="toc-backref" href="#id13"><span class="section-number">12.1.3. </span>3.反射:性能和灵活性的双刃剑</a><a class="headerlink" href="#id4" title="Permalink to this headline">¶</a></h2>
<p>要用好反射这把双刃剑，就需要详细了解反射的性能。下面的一些基准测试从多方面对比了原生调用和反射调用的区别。</p>
<section id="id5">
<h3><a class="toc-backref" href="#id14">3.1 结构体成员赋值对比</a><a class="headerlink" href="#id5" title="Permalink to this headline">¶</a></h3>
<p>反射经常被使用在结构体上，因此结构体的成员访问性能就成为了关注的重点。</p>
<p>下面例子中使用一个被实例化的结构体，访问它的成员，然后使用Go语言的基准化测试可以迅速测试出结果。</p>
<p>反射性能测试</p>
<div class="highlight-go notranslate"><div class="highlight"><pre><span></span><span class="kn">package</span> <span class="nx">example03</span>

<span class="kn">import</span> <span class="p">(</span>
    <span class="s">&quot;reflect&quot;</span>
    <span class="s">&quot;testing&quot;</span>
<span class="p">)</span>

<span class="kd">type</span> <span class="nx">data</span> <span class="kd">struct</span> <span class="p">{</span>
    <span class="nx">Hp</span> <span class="kt">int</span>
<span class="p">}</span>

<span class="c1">// ----------------------------------------</span>
<span class="c1">// 结构体成员赋值对比</span>
<span class="kd">func</span> <span class="nx">BenchmarkNativeAssign</span><span class="p">(</span><span class="nx">b</span> <span class="o">*</span><span class="nx">testing</span><span class="p">.</span><span class="nx">B</span><span class="p">)</span> <span class="p">{</span>
    <span class="c1">// 实例化结构体</span>
    <span class="nx">v</span> <span class="o">:=</span> <span class="nx">data</span><span class="p">{</span><span class="nx">Hp</span><span class="p">:</span> <span class="mi">2</span><span class="p">}</span>
    <span class="c1">// 停止基准测试的计时器</span>
    <span class="nx">b</span><span class="p">.</span><span class="nx">StopTimer</span><span class="p">()</span>
    <span class="c1">// 重置基准测试计时器数据</span>
    <span class="nx">b</span><span class="p">.</span><span class="nx">ResetTimer</span><span class="p">()</span>
    <span class="c1">// 重新启动基准测试计时器</span>
    <span class="nx">b</span><span class="p">.</span><span class="nx">StartTimer</span><span class="p">()</span>
    <span class="c1">// 根据基准测试数据进行循环测试</span>
    <span class="k">for</span> <span class="nx">i</span> <span class="o">:=</span> <span class="mi">0</span><span class="p">;</span> <span class="nx">i</span> <span class="p">&lt;</span> <span class="nx">b</span><span class="p">.</span><span class="nx">N</span><span class="p">;</span> <span class="nx">i</span><span class="o">++</span> <span class="p">{</span>
        <span class="nx">v</span><span class="p">.</span><span class="nx">Hp</span> <span class="p">=</span> <span class="mi">3</span>
    <span class="p">}</span>
<span class="p">}</span>

<span class="c1">// 原生结构体的赋值过程</span>
<span class="kd">func</span> <span class="nx">BenchmarkReflectAssign</span><span class="p">(</span><span class="nx">b</span> <span class="o">*</span><span class="nx">testing</span><span class="p">.</span><span class="nx">B</span><span class="p">)</span> <span class="p">{</span>
    <span class="nx">v</span> <span class="o">:=</span> <span class="nx">data</span><span class="p">{</span><span class="nx">Hp</span><span class="p">:</span> <span class="mi">2</span><span class="p">}</span>
    <span class="c1">// 取出结构体指针的反射值对象并取其元素</span>
    <span class="nx">vv</span> <span class="o">:=</span> <span class="nx">reflect</span><span class="p">.</span><span class="nx">ValueOf</span><span class="p">(</span><span class="o">&amp;</span><span class="nx">v</span><span class="p">).</span><span class="nx">Elem</span><span class="p">()</span>

    <span class="c1">// 根据名字取结构体成员</span>
    <span class="nx">f</span> <span class="o">:=</span> <span class="nx">vv</span><span class="p">.</span><span class="nx">FieldByName</span><span class="p">(</span><span class="s">&quot;Hp&quot;</span><span class="p">)</span>
    <span class="nx">b</span><span class="p">.</span><span class="nx">StopTimer</span><span class="p">()</span>
    <span class="nx">b</span><span class="p">.</span><span class="nx">ResetTimer</span><span class="p">()</span>
    <span class="nx">b</span><span class="p">.</span><span class="nx">StartTimer</span><span class="p">()</span>
    <span class="k">for</span> <span class="nx">i</span> <span class="o">:=</span> <span class="mi">0</span><span class="p">;</span> <span class="nx">i</span> <span class="p">&lt;</span> <span class="nx">b</span><span class="p">.</span><span class="nx">N</span><span class="p">;</span> <span class="nx">i</span><span class="o">++</span> <span class="p">{</span>
        <span class="nx">f</span><span class="p">.</span><span class="nx">SetInt</span><span class="p">(</span><span class="mi">3</span><span class="p">)</span>
    <span class="p">}</span>
<span class="p">}</span>



<span class="c1">// ----------------------------------------</span>
<span class="c1">// 结构体成员搜索并赋值对比</span>
<span class="kd">func</span> <span class="nx">BenchmarkReflectFindFieldAndAssign</span><span class="p">(</span><span class="nx">b</span> <span class="o">*</span><span class="nx">testing</span><span class="p">.</span><span class="nx">B</span><span class="p">)</span> <span class="p">{</span>
    <span class="nx">v</span> <span class="o">:=</span> <span class="nx">data</span><span class="p">{</span><span class="nx">Hp</span><span class="p">:</span> <span class="mi">2</span><span class="p">}</span>
    <span class="c1">// 取出结构体指针的反射值对象并取其元素</span>
    <span class="nx">vv</span> <span class="o">:=</span> <span class="nx">reflect</span><span class="p">.</span><span class="nx">ValueOf</span><span class="p">(</span><span class="o">&amp;</span><span class="nx">v</span><span class="p">).</span><span class="nx">Elem</span><span class="p">()</span>
    <span class="nx">b</span><span class="p">.</span><span class="nx">StopTimer</span><span class="p">()</span>
    <span class="nx">b</span><span class="p">.</span><span class="nx">ResetTimer</span><span class="p">()</span>
    <span class="nx">b</span><span class="p">.</span><span class="nx">StartTimer</span><span class="p">()</span>
    <span class="c1">// 这段代码将反射值对象的FieldByName()方法与SetInt()方法放在循环里进行检测，</span>
    <span class="c1">// 主要对比测试FieldByName()方法对性能的影响。</span>
    <span class="k">for</span> <span class="nx">i</span> <span class="o">:=</span> <span class="mi">0</span><span class="p">;</span> <span class="nx">i</span> <span class="p">&lt;</span> <span class="nx">b</span><span class="p">.</span><span class="nx">N</span><span class="p">;</span> <span class="nx">i</span><span class="o">++</span> <span class="p">{</span>
        <span class="nx">vv</span><span class="p">.</span><span class="nx">FieldByName</span><span class="p">(</span><span class="s">&quot;Hp&quot;</span><span class="p">).</span><span class="nx">SetInt</span><span class="p">(</span><span class="mi">3</span><span class="p">)</span>
    <span class="p">}</span>
<span class="p">}</span>


<span class="c1">// --------------------------------------------------------</span>
<span class="c1">// 调用函数对比</span>
<span class="c1">// 一个普通函数</span>
<span class="kd">func</span> <span class="nx">foo</span><span class="p">(</span><span class="nx">v</span> <span class="kt">int</span><span class="p">)</span> <span class="p">{</span>
<span class="p">}</span>
<span class="kd">func</span> <span class="nx">BenchmarkNativeCall</span><span class="p">(</span><span class="nx">b</span> <span class="o">*</span><span class="nx">testing</span><span class="p">.</span><span class="nx">B</span><span class="p">)</span> <span class="p">{</span>
    <span class="k">for</span> <span class="nx">i</span> <span class="o">:=</span> <span class="mi">0</span><span class="p">;</span> <span class="nx">i</span> <span class="p">&lt;</span> <span class="nx">b</span><span class="p">.</span><span class="nx">N</span><span class="p">;</span> <span class="nx">i</span><span class="o">++</span> <span class="p">{</span>
        <span class="c1">// 原生函数调用</span>
        <span class="nx">foo</span><span class="p">(</span><span class="mi">0</span><span class="p">)</span>
    <span class="p">}</span>
<span class="p">}</span>
<span class="kd">func</span> <span class="nx">BenchmarkReflectCall</span><span class="p">(</span><span class="nx">b</span> <span class="o">*</span><span class="nx">testing</span><span class="p">.</span><span class="nx">B</span><span class="p">)</span> <span class="p">{</span>
    <span class="c1">// 取函数的反射值对象</span>
    <span class="nx">v</span> <span class="o">:=</span> <span class="nx">reflect</span><span class="p">.</span><span class="nx">ValueOf</span><span class="p">(</span><span class="nx">foo</span><span class="p">)</span>
    <span class="nx">b</span><span class="p">.</span><span class="nx">StopTimer</span><span class="p">()</span>
    <span class="nx">b</span><span class="p">.</span><span class="nx">ResetTimer</span><span class="p">()</span>
    <span class="nx">b</span><span class="p">.</span><span class="nx">StartTimer</span><span class="p">()</span>
    <span class="k">for</span> <span class="nx">i</span> <span class="o">:=</span> <span class="mi">0</span><span class="p">;</span> <span class="nx">i</span> <span class="p">&lt;</span> <span class="nx">b</span><span class="p">.</span><span class="nx">N</span><span class="p">;</span> <span class="nx">i</span><span class="o">++</span> <span class="p">{</span>
        <span class="c1">// 反射调用函数</span>
        <span class="nx">v</span><span class="p">.</span><span class="nx">Call</span><span class="p">([]</span><span class="nx">reflect</span><span class="p">.</span><span class="nx">Value</span><span class="p">{</span><span class="nx">reflect</span><span class="p">.</span><span class="nx">ValueOf</span><span class="p">(</span><span class="mi">2</span><span class="p">)})</span>
    <span class="p">}</span>
<span class="p">}</span>
</pre></div>
</div>
</section>
<section id="id6">
<h3><a class="toc-backref" href="#id15">3.2 基准测试结果对比</a><a class="headerlink" href="#id6" title="Permalink to this headline">¶</a></h3>
<p>测试结果如下：</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span>$ go test -v -bench=.
goos: linux
goarch: amd64
BenchmarkNativeAssign-4                        2000000000               0.32 ns/op
BenchmarkReflectAssign-4                       300000000               4.42 ns/op
BenchmarkReflectFindFieldAndAssign-4           20000000               91.6 ns/op
BenchmarkNativeCall-4                          2000000000               0.33 ns/op
BenchmarkReflectCall-4                         10000000               163 ns/op
PASS
</pre></div>
</div>
<p>经过基准测试结果的数值分析及对比，最终得出以下结论：</p>
<ul class="simple">
<li><p>能使用原生代码时，尽量避免反射操作。</p></li>
<li><p>提前缓冲反射值对象，对性能有很大的帮助。</p></li>
<li><p>避免反射函数调用，实在需要调用时，先提前缓冲函数参数列表，并且尽量少地使用返回值。</p></li>
</ul>
</section>
</section>
<section id="nil">
<h2><a class="toc-backref" href="#id16"><span class="section-number">12.1.4. </span>4.接口的nil判断</a><a class="headerlink" href="#nil" title="Permalink to this headline">¶</a></h2>
<p>nil在Go语言中只能被赋值给指针和接口。</p>
<p>接口在底层的实现有两个部分：type和data。</p>
<p>在源码中，显式地将nil赋值给接口时，接口的type和data都将为nil。</p>
<p>此时，接口与nil值判断是相等的。但如果将一个带有类型的nil赋值给接口时，只有data为nil，而type为nil，此时，接口与nil判断将不相等。</p>
<section id="id7">
<h3><a class="toc-backref" href="#id17">4.1 接口与nil不相等</a><a class="headerlink" href="#id7" title="Permalink to this headline">¶</a></h3>
<p>下面代码使用 MyImplement() 实现 fmt 包中的 Stringer
接口，这个接口的定义如下：</p>
<div class="highlight-go notranslate"><div class="highlight"><pre><span></span><span class="kn">package</span> <span class="nx">main</span>

<span class="kn">import</span> <span class="s">&quot;fmt&quot;</span>

<span class="c1">// 定义一个结构体</span>
<span class="kd">type</span> <span class="nx">MyImplement</span> <span class="kd">struct</span><span class="p">{}</span>

<span class="c1">// 实现fmt.Stringer的String方法</span>
<span class="kd">func</span> <span class="p">(</span><span class="nx">m</span> <span class="o">*</span><span class="nx">MyImplement</span><span class="p">)</span> <span class="nx">String</span><span class="p">()</span> <span class="kt">string</span> <span class="p">{</span>
    <span class="k">return</span> <span class="s">&quot;hi&quot;</span>
<span class="p">}</span>

<span class="c1">// 在函数中返回fmt.Stringer接口</span>
<span class="kd">func</span> <span class="nx">GetStringer</span><span class="p">()</span> <span class="nx">fmt</span><span class="p">.</span><span class="nx">Stringer</span> <span class="p">{</span>
    <span class="c1">// 赋nil</span>
    <span class="kd">var</span> <span class="nx">s</span> <span class="o">*</span><span class="nx">MyImplement</span> <span class="p">=</span> <span class="kc">nil</span>
    <span class="c1">// 返回变量</span>
    <span class="k">return</span> <span class="nx">s</span>
<span class="p">}</span>
<span class="kd">func</span> <span class="nx">main</span><span class="p">()</span> <span class="p">{</span>
    <span class="c1">// 判断返回值是否为nil</span>
    <span class="k">if</span> <span class="nx">GetStringer</span><span class="p">()</span> <span class="o">==</span> <span class="kc">nil</span> <span class="p">{</span>
        <span class="nx">fmt</span><span class="p">.</span><span class="nx">Println</span><span class="p">(</span><span class="s">&quot;GetStringer() == nil&quot;</span><span class="p">)</span>
    <span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
        <span class="nx">fmt</span><span class="p">.</span><span class="nx">Println</span><span class="p">(</span><span class="s">&quot;GetStringer() != nil&quot;</span><span class="p">)</span>
    <span class="p">}</span>
<span class="p">}</span>
</pre></div>
</div>
<p>使用 GetStringer() 的返回值与 nil 判断时，虽然接口里的 value 为 nil，但
type 带有 *MyImplement 信息，使用 == 判断相等时，依然不为 nil。</p>
<p><strong>发现 nil 类型值返回时直接返回 nil</strong></p>
<div class="highlight-go notranslate"><div class="highlight"><pre><span></span><span class="kn">package</span> <span class="nx">main</span>

<span class="kn">import</span> <span class="s">&quot;fmt&quot;</span>

<span class="c1">// 定义一个结构体</span>
<span class="kd">type</span> <span class="nx">MyImplement</span> <span class="kd">struct</span><span class="p">{}</span>

<span class="c1">// 实现fmt.Stringer的String方法</span>
<span class="kd">func</span> <span class="p">(</span><span class="nx">m</span> <span class="o">*</span><span class="nx">MyImplement</span><span class="p">)</span> <span class="nx">String</span><span class="p">()</span> <span class="kt">string</span> <span class="p">{</span>
    <span class="k">return</span> <span class="s">&quot;hi&quot;</span>
<span class="p">}</span>

<span class="c1">// 在函数中返回fmt.Stringer接口</span>
<span class="kd">func</span> <span class="nx">GetStringer</span><span class="p">()</span> <span class="nx">fmt</span><span class="p">.</span><span class="nx">Stringer</span> <span class="p">{</span>
    <span class="kd">var</span> <span class="nx">s</span> <span class="o">*</span><span class="nx">MyImplement</span> <span class="p">=</span> <span class="kc">nil</span>
    <span class="k">if</span> <span class="nx">s</span> <span class="o">==</span> <span class="kc">nil</span> <span class="p">{</span>
        <span class="k">return</span> <span class="kc">nil</span>
    <span class="p">}</span>
    <span class="k">return</span> <span class="nx">s</span>
<span class="p">}</span>

<span class="kd">func</span> <span class="nx">main</span><span class="p">()</span> <span class="p">{</span>
    <span class="c1">// 判断返回值是否为nil</span>
    <span class="k">if</span> <span class="nx">GetStringer</span><span class="p">()</span> <span class="o">==</span> <span class="kc">nil</span> <span class="p">{</span>
        <span class="nx">fmt</span><span class="p">.</span><span class="nx">Println</span><span class="p">(</span><span class="s">&quot;GetStringer() == nil&quot;</span><span class="p">)</span>
    <span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
        <span class="nx">fmt</span><span class="p">.</span><span class="nx">Println</span><span class="p">(</span><span class="s">&quot;GetStringer() != nil&quot;</span><span class="p">)</span>
    <span class="p">}</span>
<span class="p">}</span>
</pre></div>
</div>
</section>
</section>
</section>


           </div>
          </div>
          <footer><div class="rst-footer-buttons" role="navigation" aria-label="Footer">
        <a href="index.html" class="btn btn-neutral float-left" title="12. 避坑与技巧" accesskey="p" rel="prev"><span class="fa fa-arrow-circle-left" aria-hidden="true"></span> Previous</a>
        <a href="../../Go_vs_Python/index.html" class="btn btn-neutral float-right" title="Go vs Python" accesskey="n" rel="next">Next <span class="fa fa-arrow-circle-right" aria-hidden="true"></span></a>
    </div>

  <hr/>

  <div role="contentinfo">
    <p>&#169; Copyright 2019, huxiaojian.</p>
  </div>

  Built with <a href="https://www.sphinx-doc.org/">Sphinx</a> using a
    <a href="https://github.com/readthedocs/sphinx_rtd_theme">theme</a>
    provided by <a href="https://readthedocs.org">Read the Docs</a>.
   

</footer>
        </div>
      </div>
    </section>
  </div>
  <script>
      jQuery(function () {
          SphinxRtdTheme.Navigation.enable(true);
      });
  </script> 

</body>
</html>