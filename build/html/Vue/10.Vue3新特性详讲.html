<!DOCTYPE html>
<html class="writer-html5" lang="en" >
<head>
  <meta charset="utf-8" /><meta name="generator" content="Docutils 0.17: http://docutils.sourceforge.net/" />

  <meta name="viewport" content="width=device-width, initial-scale=1.0" />
  <title>10. Vue3新特性详讲 &mdash; 运维开发修炼之路</title>
      <link rel="stylesheet" href="../_static/pygments.css" type="text/css" />
      <link rel="stylesheet" href="../_static/css/theme.css" type="text/css" />
  <!--[if lt IE 9]>
    <script src="../_static/js/html5shiv.min.js"></script>
  <![endif]-->
  
        <script data-url_root="../" id="documentation_options" src="../_static/documentation_options.js"></script>
        <script src="../_static/jquery.js"></script>
        <script src="../_static/underscore.js"></script>
        <script src="../_static/doctools.js"></script>
    <script src="../_static/js/theme.js"></script>
    <link rel="index" title="Index" href="../genindex.html" />
    <link rel="search" title="Search" href="../search.html" />
    <link rel="next" title="11. TypeScript入门" href="11.TypeScript%E5%85%A5%E9%97%A8.html" />
    <link rel="prev" title="9. 服务器端渲染" href="09.%E6%9C%8D%E5%8A%A1%E5%99%A8%E7%AB%AF%E6%B8%B2%E6%9F%93.html" /> 
</head>

<body class="wy-body-for-nav"> 
  <div class="wy-grid-for-nav">
    <nav data-toggle="wy-nav-shift" class="wy-nav-side">
      <div class="wy-side-scroll">
        <div class="wy-side-nav-search" >
            <a href="../index.html" class="icon icon-home"> 小健_Python_go_Devops
            <img src="../_static/python_go.png" class="logo" alt="Logo"/>
          </a>
              <div class="version">
                2.0
              </div>
<div role="search">
  <form id="rtd-search-form" class="wy-form" action="../search.html" method="get">
    <input type="text" name="q" placeholder="Search docs" />
    <input type="hidden" name="check_keywords" value="yes" />
    <input type="hidden" name="area" value="default" />
  </form>
</div>
        </div><div class="wy-menu wy-menu-vertical" data-spy="affix" role="navigation" aria-label="Navigation menu">
              <ul class="current">
<li class="toctree-l1"><a class="reference internal" href="../Go/index.html">Go语言学习</a></li>
<li class="toctree-l1"><a class="reference internal" href="../Go_vs_Python/index.html">Go vs Python</a></li>
<li class="toctree-l1"><a class="reference internal" href="../Python/index.html">Python全栈系列</a></li>
<li class="toctree-l1"><a class="reference internal" href="../Python%E6%B5%8B%E8%AF%95%E5%BC%80%E5%8F%91%E5%85%A5%E9%97%A8%E4%B8%8E%E5%AE%9E%E8%B7%B5/index.html">Python测试开发入门与实践</a></li>
<li class="toctree-l1 current"><a class="reference internal" href="index.html">Vue.js企业开发实战</a><ul class="current">
<li class="toctree-l2"><a class="reference internal" href="01.Vue%E5%9F%BA%E7%A1%80%E5%85%A5%E9%97%A8.html">1. Vue基础入门</a></li>
<li class="toctree-l2"><a class="reference internal" href="02.Vue%E5%86%85%E7%BD%AE%E6%8C%87%E4%BB%A4.html">2. Vue内置指令</a></li>
<li class="toctree-l2"><a class="reference internal" href="03.Vue%E5%AE%9E%E4%BE%8B%E6%A0%B8%E5%BF%83%E9%80%89%E9%A1%B9.html">3. Vue实例核心选项</a></li>
<li class="toctree-l2"><a class="reference internal" href="04.Vue%E5%B7%A5%E7%A8%8B%E5%8C%96%E9%A1%B9%E7%9B%AE.html">4. Vue工程化项目</a></li>
<li class="toctree-l2"><a class="reference internal" href="05.%E6%B7%B1%E5%85%A5%E4%BA%86%E8%A7%A3Vue%E7%BB%84%E4%BB%B6.html">5. 深入了解Vue组件</a></li>
<li class="toctree-l2"><a class="reference internal" href="06.Vue-Router%E8%B7%AF%E7%94%B1.html">6. Vue-Router路由</a></li>
<li class="toctree-l2"><a class="reference internal" href="07.Vuex%E7%8A%B6%E6%80%81%E7%AE%A1%E7%90%86.html">7. Vuex状态管理</a></li>
<li class="toctree-l2"><a class="reference internal" href="08.Vue%E7%9A%84%E5%BC%82%E6%AD%A5%E8%AF%B7%E6%B1%82.html">8. Vue的异步请求</a></li>
<li class="toctree-l2"><a class="reference internal" href="09.%E6%9C%8D%E5%8A%A1%E5%99%A8%E7%AB%AF%E6%B8%B2%E6%9F%93.html">9. 服务器端渲染</a></li>
<li class="toctree-l2 current"><a class="current reference internal" href="#">10. Vue3新特性详讲</a><ul>
<li class="toctree-l3"><a class="reference internal" href="#id1">10.1. 1.为什么要用Vue3</a><ul>
<li class="toctree-l4"><a class="reference internal" href="#vue2">10.1.1. 1.1 Vue2对复杂功能的处理不友好</a></li>
<li class="toctree-l4"><a class="reference internal" href="#vue2mixin">10.1.2. 1.2 Vue2中mixin存在缺陷</a></li>
<li class="toctree-l4"><a class="reference internal" href="#vue2typescript">10.1.3. 1.3 Vue2对TypeScript的支持有限</a></li>
</ul>
</li>
<li class="toctree-l3"><a class="reference internal" href="#id2">10.2. 2.Vue3简介</a><ul>
<li class="toctree-l4"><a class="reference internal" href="#id3">10.2.1. 2.1 Vue3增加了以下新特性</a></li>
</ul>
</li>
<li class="toctree-l3"><a class="reference internal" href="#id5">10.3. 3.Vue3项目搭建</a></li>
<li class="toctree-l3"><a class="reference internal" href="#id6">10.4. 4.Vue3项目的目录结构</a></li>
<li class="toctree-l3"><a class="reference internal" href="#vue-js-3-01api">10.5. 5.Vue.js 3.0的新变化1—组合API</a><ul>
<li class="toctree-l4"><a class="reference internal" href="#setup">10.5.1. 5.1 setup()函数</a></li>
<li class="toctree-l4"><a class="reference internal" href="#reactive">10.5.2. 5.2 reactive()函数</a></li>
<li class="toctree-l4"><a class="reference internal" href="#ref">10.5.3. 5.3 ref()函数</a></li>
<li class="toctree-l4"><a class="reference internal" href="#id10">10.5.4. 3.4 ref辅助操作的函数。</a></li>
<li class="toctree-l4"><a class="reference internal" href="#id11">10.5.5. 3.5 Vue3中的响应式对象</a></li>
<li class="toctree-l4"><a class="reference internal" href="#id12">10.5.6. 3.6 生命周期的改变</a></li>
<li class="toctree-l4"><a class="reference internal" href="#watch">10.5.7. 3.7 watch()侦测变化</a></li>
<li class="toctree-l4"><a class="reference internal" href="#vue3typescript">10.5.8. 3.8 Vue3更好地支持TypeScript</a></li>
<li class="toctree-l4"><a class="reference internal" href="#teleport">10.5.9. 3.9 Teleport传送门</a></li>
<li class="toctree-l4"><a class="reference internal" href="#suspense">10.5.10. 3.10 Suspense异步请求</a></li>
<li class="toctree-l4"><a class="reference internal" href="#api">10.5.11. 3.11 全局API修改</a></li>
</ul>
</li>
<li class="toctree-l3"><a class="reference internal" href="#id13">10.6. 7 vue3实战笔记 | 快速入门</a></li>
<li class="toctree-l3"><a class="reference internal" href="#vue3-0">10.7. 8.全面总结Vue3.0 的新特性</a></li>
</ul>
</li>
<li class="toctree-l2"><a class="reference internal" href="11.TypeScript%E5%85%A5%E9%97%A8.html">11. TypeScript入门</a></li>
<li class="toctree-l2"><a class="reference internal" href="12.Vite.html">12. Vite</a></li>
<li class="toctree-l2"><a class="reference internal" href="13.Vue3%E5%AE%9E%E8%B7%B5.html">13. Vue3 实践</a></li>
</ul>
</li>
<li class="toctree-l1"><a class="reference internal" href="../Vue_Node.js/index.html">Vue.js+Node.js开发实战</a></li>
</ul>

        </div>
      </div>
    </nav>

    <section data-toggle="wy-nav-shift" class="wy-nav-content-wrap"><nav class="wy-nav-top" aria-label="Mobile navigation menu" >
          <i data-toggle="wy-nav-top" class="fa fa-bars"></i>
          <a href="../index.html">小健_Python_go_Devops</a>
      </nav>

      <div class="wy-nav-content">
        <div class="rst-content">
          <div role="navigation" aria-label="Page navigation">
  <ul class="wy-breadcrumbs">
      <li><a href="../index.html" class="icon icon-home"></a> &raquo;</li>
          <li><a href="index.html">Vue.js企业开发实战</a> &raquo;</li>
      <li><span class="section-number">10. </span>Vue3新特性详讲</li>
      <li class="wy-breadcrumbs-aside">
            <a href="../_sources/Vue/10.Vue3新特性详讲.rst.txt" rel="nofollow"> View page source</a>
      </li>
  </ul>
  <hr/>
</div>
          <div role="main" class="document" itemscope="itemscope" itemtype="http://schema.org/Article">
           <div itemprop="articleBody">
             
  <div class="contents topic" id="contents">
<p class="topic-title">Contents</p>
<ul class="simple">
<li><p><a class="reference internal" href="#vue3" id="id14">Vue3新特性详讲</a></p>
<ul>
<li><p><a class="reference internal" href="#id1" id="id15">1.为什么要用Vue3</a></p>
<ul>
<li><p><a class="reference internal" href="#vue2" id="id16">1.1 Vue2对复杂功能的处理不友好</a></p></li>
<li><p><a class="reference internal" href="#vue2mixin" id="id17">1.2 Vue2中mixin存在缺陷</a></p></li>
<li><p><a class="reference internal" href="#vue2typescript" id="id18">1.3 Vue2对TypeScript的支持有限</a></p></li>
</ul>
</li>
<li><p><a class="reference internal" href="#id2" id="id19">2.Vue3简介</a></p>
<ul>
<li><p><a class="reference internal" href="#id3" id="id20">2.1 Vue3增加了以下新特性</a></p></li>
</ul>
</li>
<li><p><a class="reference internal" href="#id5" id="id21">3.Vue3项目搭建</a></p></li>
<li><p><a class="reference internal" href="#id6" id="id22">4.Vue3项目的目录结构</a></p></li>
<li><p><a class="reference internal" href="#vue-js-3-01api" id="id23">5.Vue.js 3.0的新变化1—组合API</a></p>
<ul>
<li><p><a class="reference internal" href="#setup" id="id24">5.1 setup()函数</a></p></li>
<li><p><a class="reference internal" href="#reactive" id="id25">5.2 reactive()函数</a></p></li>
<li><p><a class="reference internal" href="#ref" id="id26">5.3 ref()函数</a></p></li>
<li><p><a class="reference internal" href="#id10" id="id27">3.4 ref辅助操作的函数。</a></p></li>
<li><p><a class="reference internal" href="#id11" id="id28">3.5 Vue3中的响应式对象</a></p></li>
<li><p><a class="reference internal" href="#id12" id="id29">3.6 生命周期的改变</a></p></li>
<li><p><a class="reference internal" href="#watch" id="id30">3.7 watch()侦测变化</a></p></li>
<li><p><a class="reference internal" href="#vue3typescript" id="id31">3.8 Vue3更好地支持TypeScript</a></p></li>
<li><p><a class="reference internal" href="#teleport" id="id32">3.9 Teleport传送门</a></p></li>
<li><p><a class="reference internal" href="#suspense" id="id33">3.10 Suspense异步请求</a></p></li>
<li><p><a class="reference internal" href="#api" id="id34">3.11 全局API修改</a></p></li>
</ul>
</li>
<li><p><a class="reference internal" href="#id13" id="id35">7 vue3实战笔记 | 快速入门</a></p></li>
<li><p><a class="reference internal" href="#vue3-0" id="id36">8.全面总结Vue3.0 的新特性</a></p></li>
</ul>
</li>
</ul>
</div>
<section id="vue3">
<h1><a class="toc-backref" href="#id14"><span class="section-number">10. </span>Vue3新特性详讲</a><a class="headerlink" href="#vue3" title="Permalink to this headline">¶</a></h1>
<section id="id1">
<h2><a class="toc-backref" href="#id15"><span class="section-number">10.1. </span>1.为什么要用Vue3</a><a class="headerlink" href="#id1" title="Permalink to this headline">¶</a></h2>
<p>在学习Vue 3的新特性之前，先来看一下Vue 3设计的目的是什么，为什么要对Vue
2做出很大的改变，以及Vue 3到底解决了什么问题。</p>
<p>像Vue这样全球闻名的前端框架，在任何一次改动时，设计者都是经过深思熟虑的权衡，所以，Vue
3的出现肯定是解决了某些棘手的问题。下面介绍一下Vue 2中遇到的问题。</p>
<section id="vue2">
<h3><a class="toc-backref" href="#id16"><span class="section-number">10.1.1. </span>1.1 Vue2对复杂功能的处理不友好</a><a class="headerlink" href="#vue2" title="Permalink to this headline">¶</a></h3>
<p>在使用Vue
2开发项目的过程中，随着更加复杂的业务逻辑的增加，复杂组件的代码变得难以维护。尤其是一个开发人员从别的开发人员手中接过一个新项目时，这个问题更突出。究其根本原因，Vue
2中的API是通过选项来组织代码的，但是大部分情况下，通过逻辑来组织代码会更有意义。</p>
<p>Vue
2中缺少多个组件之间提取和复用逻辑的机制，现有的重用机制都有很多缺点。</p>
</section>
<section id="vue2mixin">
<h3><a class="toc-backref" href="#id17"><span class="section-number">10.1.2. </span>1.2 Vue2中mixin存在缺陷</a><a class="headerlink" href="#vue2mixin" title="Permalink to this headline">¶</a></h3>
</section>
<section id="vue2typescript">
<h3><a class="toc-backref" href="#id18"><span class="section-number">10.1.3. </span>1.3 Vue2对TypeScript的支持有限</a><a class="headerlink" href="#vue2typescript" title="Permalink to this headline">¶</a></h3>
<p>Vue框架的开发者都清楚，Vue
2对TypeScript的支持并不友好，这是因为在Vue中是依赖this上下文对象向外暴露属性，但是在组件中的this与普通的JavaScript中的Object对象处理的方式不同。</p>
<p>其实，在Vue
2设计时就没有考虑对TypeScript的集成和强制类型的相关问题，所以才导致在Vue
2中使用TypeScript有很多阻碍。</p>
</section>
</section>
<section id="id2">
<h2><a class="toc-backref" href="#id19"><span class="section-number">10.2. </span>2.Vue3简介</a><a class="headerlink" href="#id2" title="Permalink to this headline">¶</a></h2>
<p>众所周知，前端技术一直更新得很快，特别是前端框架，更新速度更是极快的。</p>
<p>在2020年4月21日晚上，Vue的作者尤雨溪在B站上直播分享了Vue 3
Beta的最新进展，直到9月19日，Vue 3正式版才发布。</p>
<p>这个耗时两年，历经99位代码贡献者，2600多次代码提交的大版本更新终于和众多开发者见面了。</p>
<p>为了减少前端开发者的学习成本，Vue 2的大部分特性保留到了Vue
3中，开发者可以像使用Vue 2一样，原封不动地使用Vue
3，这是遵循了渐进式的准则。如果你是一个保守派，只想使用Vue
2的写法，也是完全没有问题的。</p>
<section id="id3">
<h3><a class="toc-backref" href="#id20"><span class="section-number">10.2.1. </span>2.1 Vue3增加了以下新特性</a><a class="headerlink" href="#id3" title="Permalink to this headline">¶</a></h3>
<section id="id4">
<h4>1. Vue3在性能上有很大提升<a class="headerlink" href="#id4" title="Permalink to this headline">¶</a></h4>
<p>但没有哪一位开发者不想要更快、更轻的框架。Vue
3给开发者带来了极致的开发体验。整个Vue
3的代码库被重新编写成了一系列独立的、可实现不同功能的模块。</p>
<p>据官方介绍，Vue
3的代码打包大小减少了41%，初次渲染速度提升了55%，更新效率提升了33%，内存使用率减少了54%。这些数据都得益于Vue
3中重构了虚拟DOM的写法，提升渲染速度。</p>
</section>
<section id="vue3api">
<h4>2.Vue3推出了新的API<a class="headerlink" href="#vue3api" title="Permalink to this headline">¶</a></h4>
<p>在Vue
2中遇到了一些问题，例如，复杂组件的代码变得越来越难以维护，缺少一种纯粹的多组件之间提取和复用逻辑的机制。</p>
<p>虽然Vue 2中也提供了相关的解决方案，但是在Vue
2中对于重用机制这一部分也存在一些弊端。</p>
<p>所以，Vue 3中设计了Composition API，这也是本章重点介绍和使用的Vue
3的新特性。</p>
<p>Composition这个单词是“组合”的意思，是Vue
3新推出的一系列API的合集，主要包括了以下API。</p>
<p>（1）ref。</p>
<p>（2）reactive。</p>
<p>（3）computed。</p>
<p>（4）watch。</p>
<p>（5）新的生命周期函数。</p>
<p>（6）支持自定义Hooks函数。</p>
<p>（7）Teleport。</p>
<p>（8）Suspense。</p>
<p>（9）全局API的修改和优化。</p>
</section>
<section id="typescript">
<h4>3.更好地支持TypeScript<a class="headerlink" href="#typescript" title="Permalink to this headline">¶</a></h4>
<p>有在Vue 2中集成TypeScript的开发者应该都体会过其中的痛苦，因为Vue
2在推出的时候没有把TypeScript作为一个考量范围，所以在设计Vue
3的时候，设计者们就痛定思痛，考虑了这方面的问题。</p>
<p>Vue
3的源代码全部都是使用TypeScript语法编写的，提供了非常完备的类型定义，在使用Vue
3开发项目时，可以把TypeScript语法深入到各个大型项目中，让开发者更加方便地享受类型推论等一系列TypeScript的红利。</p>
<p>同时，还可以在VSCode等编辑器中安装相关的插件，完美地使用TypeScript的各种功能。</p>
</section>
</section>
</section>
<section id="id5">
<h2><a class="toc-backref" href="#id21"><span class="section-number">10.3. </span>3.Vue3项目搭建</a><a class="headerlink" href="#id5" title="Permalink to this headline">¶</a></h2>
<p>Vue CLI脚手架简介</p>
<p>参考Vue工程化项目。</p>
</section>
<section id="id6">
<h2><a class="toc-backref" href="#id22"><span class="section-number">10.4. </span>4.Vue3项目的目录结构</a><a class="headerlink" href="#id6" title="Permalink to this headline">¶</a></h2>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span>目录/文件                   说明
build                  项目构建(webpack)相关代码
config                 配置目录，包括端口号等。我们初学可以使用默认的。
node_modules            npm 加载的项目依赖模块
src                    这里是我们要开发的目录，基本上要做的事情都在这个目录里。里面包含了几个目录及文件：
    assets:             放置一些图片，如logo等。
    components:         目录里面放了一个组件文件，可以不用。
    App.vue:            项目入口文件，我们也可以直接将组件写这里，而不使用 components 目录。
    main.js:            项目的核心文件。
    index.css:          样式文件。

static                  静态资源目录，如图片、字体等。
public                  公共资源目录。
test                    初始测试目录，可删除
.xxxx文件                这些是一些配置文件，包括语法配置，git配置等。
index.html              首页入口文件，你可以添加一些 meta 信息或统计代码啥的。
package.json            项目配置文件。
README.md               项目的说明文档，markdown 格式
dist                    使用 npm run build 命令打包后会生成该目录。
</pre></div>
</div>
<p>Vue 3的项目目录结构与Vue 2的类似，唯一不同的是很多.js文件改为了.ts文件。</p>
<p>其中，src目录下的shims-vue.d.ts是用来定义Vue类型的TypeScript配置文件。</p>
<p>因为.vue结尾的Vue组件文件在TypeScript中是不能被直接识别的，所以需要使用该配置文件来讲明.vue的类型，便于TypeScript进行解析。</p>
<p>在Vue
2中使用new关键字实例化Vue对象，然后通过构造函数将选项属性传入Vue实例中。而Vue
3对main.js做了修改，在Vue
3中使用的是.ts类型的文件编写的入口文件，示例代码如下：</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span>import { createApp } from &#39;vue&#39;
import App from &#39;./App.vue&#39;
import router from &#39;./router&#39;
import store from &#39;./store&#39;
import ElementPlus from &#39;element-plus&#39;
import &#39;element-plus/dist/index.css&#39;
import axios from &#39;axios&#39;

createApp(App).prototype.$axios = axios

createApp(App).use(store).use(router).use(ElementPlus).mount(&#39;#app&#39;)
</pre></div>
</div>
<p>Vue3的main.ts文件中引入了createApp函数，然后引入App.vue组件，调用createApp函数来创建Vue实例，</p>
<p>将所有的模块使用Vue实例对象进行调用，而不是像Vue
2中直接传入Vue对象的构造方法中，这是Vue 3做的很大改进。</p>
</section>
<section id="vue-js-3-01api">
<h2><a class="toc-backref" href="#id23"><span class="section-number">10.5. </span>5.Vue.js 3.0的新变化1—组合API</a><a class="headerlink" href="#vue-js-3-01api" title="Permalink to this headline">¶</a></h2>
<p>Composition
API是Vue的下一代主要版本中最常用的语法，它是一种全新的逻辑重用和代码组织的方法。在Vue
2中使用的是Options
API的方式构建组件，如果要向Vue组件中添加业务逻辑，则需要先填充选项属性，例如data、methods、computed等。</p>
<p>这种方式最大的缺点是，它本身并不是有效的JavaScript代码，需要先了解模板中可以访问哪些属性，然后使用Vue的编译器将这些属性转换成可以执行的代码，这样做既消耗了性能，又无法做更好的类型检查。</p>
<p>Composition
API设计的目的是通过将当前可用组件属性作为JavaScript函数暴露出来，这种机制可以基于功能的附加API灵活地组合组件逻辑，使Composition
API编写的代码更易读。</p>
<section id="setup">
<h3><a class="toc-backref" href="#id24"><span class="section-number">10.5.1. </span>5.1 setup()函数</a><a class="headerlink" href="#setup" title="Permalink to this headline">¶</a></h3>
<p>setup()函数是一个新的组件选项，它是组件内部使用组合API的入口点。</p>
<section id="id7">
<h4>1. setup使用注意点<a class="headerlink" href="#id7" title="Permalink to this headline">¶</a></h4>
<ol class="arabic simple">
<li><p>执行时机</p></li>
</ol>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span>beforeCreate——setup——Create
</pre></div>
</div>
<ol class="arabic simple" start="2">
<li><p>注意点</p></li>
</ol>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span>- setup函数中无法使用this.data和this.methods(因为他们还没创建出来)
- setup函数无法执行异步操作（async）
</pre></div>
</div>
<p>Composition
API的主要思想是，将Vue组件的选项属性定义为setup()函数返回的JavaScript变量，而不是将组件的功能（例如state、method、computed等）定义为对象属性。</p>
<p>setup()函数的执行时机是在beforeCreate之后，created之前。setup()函数有两个参数，第1个参数用于接收props数据。示例代码如下：</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span>&lt;template&gt;
&lt;p&gt; VUE3 新特性学习！！&lt;/p&gt;
&lt;/template&gt;

&lt;script&gt;
export default {
  props: {
    msg: {
      type: String,
      default: () =&gt; {}
    }
  },
  setup(props){
    console.log(props);
  }
}
&lt;/script&gt;

&lt;style scoped&gt;

&lt;/style&gt;
</pre></div>
</div>
<p>setup()函数的第2个参数是一个上下文对象，这个上下文对象大致包含了一些属性，示例代码如下：</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span>export default {
    name: &#39;Demo&#39;,
    props:[&#39;msg&#39;,&#39;school&#39;],
    emits:[&#39;hello&#39;],
    setup(props,context){
        console.log(&#39;---setup---&#39;,context.attrs) //相当与Vue2中的$attrs
        console.log(&#39;---setup---&#39;,context.emit) //触发自定义事件的。
        console.log(&#39;---setup---&#39;,context.slots) //插槽
        //数据
        let person = reactive({
            name:&#39;张三&#39;,
            age:18
        })

        //方法
        function test(){
            context.emit(&#39;hello&#39;,666)
        }

        //返回一个对象（常用）
        return {
            person,
            test
        }
    }
}
</pre></div>
</div>
<p>这里需要注意，在setup()函数中是无法访问this的。</p>
</section>
</section>
<section id="reactive">
<h3><a class="toc-backref" href="#id25"><span class="section-number">10.5.2. </span>5.2 reactive()函数</a><a class="headerlink" href="#reactive" title="Permalink to this headline">¶</a></h3>
<ul class="simple">
<li><p>ref 模块是用来声明简单数据类型的，例如,string , number ,boolean 等</p></li>
<li><p>reactive 模块是用来声明复杂数据类型的，例如，数组，对象等</p></li>
</ul>
<section id="id8">
<h4>1. reactive使用注意点<a class="headerlink" href="#id8" title="Permalink to this headline">¶</a></h4>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span>1. reactive参数必须是对象、json、arr
2. 如果给reactive传递其他对象，默认情况下修改对象，界面不会自动更新，想要更新，需要重新赋值的方式。
</pre></div>
</div>
<p>reactive()用来创建一个响应式对象，等价于2.x的Vue.observable，示例代码如下：</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span>&lt;template&gt;
&lt;p&gt; VUE3 新特性学习！！&lt;/p&gt;
  &lt;div&gt;
    &lt;button @click=&quot;incment()&quot;&gt;cliek Me!&lt;/button&gt;
    &lt;p&gt;
            一：{{state.count}}  二：{{state.addCount}}
    &lt;/p&gt;
  &lt;/div&gt;
&lt;/template&gt;

&lt;script&gt;
import {reactive} from &quot;vue&quot;;

export default {
  setup() {
    const state = reactive({
      // 创建响应式数据
      count: 0,
      addCount: 0
    });

    function incment() {
      state.count++;
      state.addCount = state.count * 2;
    }

    return {
      state,
      incment
    }
  }
}
&lt;/script&gt;

&lt;style scoped&gt;

&lt;/style&gt;
</pre></div>
</div>
</section>
</section>
<section id="ref">
<h3><a class="toc-backref" href="#id26"><span class="section-number">10.5.3. </span>5.3 ref()函数</a><a class="headerlink" href="#ref" title="Permalink to this headline">¶</a></h3>
<p>ref()函数用来给给定的值创建一个响应式的数据对象，ref()函数的返回值是一个对象，<strong>这个对象上只包含一个.value属性。</strong></p>
<section id="id9">
<h4>1. ref使用注意点<a class="headerlink" href="#id9" title="Permalink to this headline">¶</a></h4>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="mf">1.</span> <span class="n">ref只能实现对简单值的监听</span>
<span class="mf">2.</span> <span class="n">template中使用ref的值不用通过value获取</span>
<span class="mf">3.</span> <span class="n">js中使用ref的值必须通过value获取</span>
</pre></div>
</div>
<p>使用ref()函数定义的响应式属性，在template中访问的方法和Vue
2一样，可以直接使用模板语法的形式访问，示例代码如下：</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span>&lt;template&gt;
&lt;p&gt; VUE3 新特性学习！！&lt;/p&gt;
  &lt;li&gt;{{valueNumber}}&lt;/li&gt;
  &lt;li&gt;{{valueString}}&lt;/li&gt;
  &lt;li&gt;{{valueBoolean}}&lt;/li&gt;
  &lt;li&gt;{{valueNull}}&lt;/li&gt;
  &lt;li&gt;{{valueUndefined}}&lt;/li&gt;
&lt;/template&gt;

&lt;script&gt;
import {ref} from &quot;vue&quot;;

export default {
  setup() {
    const  valueNumber = ref(0)
    const  valueString = ref(&#39;hell world&#39;)
    const  valueBoolean = ref(&#39;true&#39;)
    const  valueNull = ref(null)
    const  valueUndefined = ref(undefined)
    return {
      valueNumber,
      valueString,
      valueBoolean,
      valueNull,
      valueUndefined
    }
  }
}
&lt;/script&gt;

&lt;style scoped&gt;

&lt;/style&gt;
</pre></div>
</div>
<p>在template使用模板语法直接访问响应式属性，示例代码如下：</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span>&lt;template&gt;
&lt;p&gt; VUE3 新特性学习！！&lt;/p&gt;
  &lt;p&gt;
    {{value}}
    {{message}}
  &lt;/p&gt;

&lt;/template&gt;

&lt;script&gt;
import {ref} from &quot;vue&quot;;

export default {
  setup() {
    const  value = ref(1)

    return {
      value,
      message: &quot;hello world&quot;
    }
  }
}
&lt;/script&gt;

&lt;style scoped&gt;
&lt;/style&gt;
</pre></div>
</div>
<p>Vue 3中的ref()函数与Vue 2中data()的区别:</p>
<p>先使用Vue 2的语法编写一个计算器的案例，示例代码如下：</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span>&lt;template&gt;
&lt;p&gt; VUE3 新特性学习！！&lt;/p&gt;

&lt;p&gt;{{count}}&lt;/p&gt;
  &lt;button @click=&quot;increment&quot;&gt;Add 1&lt;/button&gt;
  &lt;p&gt;The button above has been clicked {{ count }} times.&lt;/p&gt;
  &lt;p&gt;The computed info {{double}}&lt;/p&gt;
&lt;/template&gt;

&lt;script&gt;

export default {
  data: () =&gt; ({
    count: 1
  }),
  methods: {
    increment() {
      this.count++;
    }
  },
  computed: {
    double () {
      return this.count *2
    }
  }
}
&lt;/script&gt;

&lt;style scoped&gt;&lt;/style&gt;
</pre></div>
</div>
<p>再使用Composition API定义一个完全相同功能的组件，示例代码如下：</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span>&lt;template&gt;
&lt;p&gt; VUE3 新特性学习！！&lt;/p&gt;

&lt;p&gt;{{count}}&lt;/p&gt;
  &lt;button @click=&quot;increment&quot;&gt;Add 1&lt;/button&gt;
  &lt;p&gt;The button above has been clicked {{ count }} times.&lt;/p&gt;
  &lt;p&gt;The computed info {{double}}&lt;/p&gt;
&lt;/template&gt;

&lt;script&gt;
import {ref,computed } from &#39;vue&#39;;
export default {
  setup() {
    const count = ref(1);
    const double = computed(() =&gt; count.value *2);
    function increment() {
      count.value++
    }
    return {
      count,
      double,
      increment
    }
  }
}
&lt;/script&gt;

&lt;style scoped&gt;
&lt;/style&gt;
</pre></div>
</div>
<p>在上面的示例中，使用Composition
API提供的ref()函数定义了一个响应式变量，其作用与Vue
2的data变量几乎相同。</p>
<p>在Vue
3的示例代码中，increment方法是一个普通的JavaScript函数，需要更改子属性count的value才能更改响应式变量，这是因为使用ref()函数创建的响应式变量必须是对象，以便于在传递的时候保持一致。</p>
<p>Composition
API提供了更方便的逻辑提取方式，还是以上面的代码为例，使用Composition提取Counter.vue组件的代码，创建useCounter.js文件，示例代码如下：</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="kn">import</span> <span class="p">{</span><span class="n">ref</span><span class="p">,</span> <span class="n">computed</span><span class="p">}</span> <span class="kn">from</span> <span class="s1">&#39;vue&#39;</span><span class="p">;</span>

<span class="n">export</span> <span class="n">default</span> <span class="p">{</span>
  <span class="n">setup</span><span class="p">()</span> <span class="p">{</span>
    <span class="n">const</span> <span class="n">count</span> <span class="o">=</span> <span class="n">ref</span><span class="p">(</span><span class="mi">1</span><span class="p">);</span>
    <span class="n">const</span> <span class="n">double</span> <span class="o">=</span> <span class="n">computed</span><span class="p">(()</span> <span class="o">=&gt;</span> <span class="n">count</span><span class="o">.</span><span class="n">value</span> <span class="o">*</span> <span class="mi">2</span><span class="p">);</span>

    <span class="n">function</span> <span class="n">increment</span><span class="p">()</span> <span class="p">{</span>
      <span class="n">count</span><span class="o">.</span><span class="n">value</span><span class="o">++</span>
    <span class="p">}</span>

    <span class="k">return</span> <span class="p">{</span>
      <span class="n">count</span><span class="p">,</span>
      <span class="n">double</span><span class="p">,</span>
      <span class="n">increment</span>
    <span class="p">}</span>
  <span class="p">}</span>
<span class="p">}</span>
</pre></div>
</div>
<p>如果要在其他组件中使用该函数，只需将模块导入组件文件并调用它，导入的模块是一个函数，该函数将从setup()函数中返回定义的变量。示例代码如下：</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span>&lt;template&gt;
&lt;p&gt; VUE3 新特性学习！！&lt;/p&gt;

&lt;p&gt;{{count}}&lt;/p&gt;
  &lt;button @click=&quot;increment&quot;&gt;Add 1&lt;/button&gt;
  &lt;p&gt;The button above has been clicked {{ count }} times.&lt;/p&gt;
  &lt;p&gt;The computed info {{double}}&lt;/p&gt;
&lt;/template&gt;

&lt;script&gt;
import useCounter from &quot;./useCounter.js&quot;
export default {
  setup() {
    const { count, increment, double} = useCounter.setup();
    return {
      count,
      increment,
      double
    }

  }
}
&lt;/script&gt;

&lt;style scoped&gt;

&lt;/style&gt;
</pre></div>
</div>
<p>这种操作还可以解决Vue 2中mixins命名冲突的问题，示例代码如下：</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">export</span> <span class="n">default</span> <span class="p">{</span>
  <span class="n">setup</span><span class="p">()</span> <span class="p">{</span>
    <span class="n">const</span> <span class="p">{</span> <span class="n">count1</span><span class="p">,</span> <span class="n">increment1</span><span class="p">}</span> <span class="o">=</span> <span class="n">useCounter1</span><span class="o">.</span><span class="n">setup</span><span class="p">();</span>
    <span class="n">const</span> <span class="p">{</span> <span class="n">count2</span><span class="p">,</span> <span class="n">increment2</span><span class="p">}</span> <span class="o">=</span> <span class="n">useCounter2</span><span class="o">.</span><span class="n">setup</span><span class="p">();</span>

    <span class="k">return</span> <span class="p">{</span>
      <span class="n">count1</span><span class="p">,</span>
      <span class="n">increment1</span><span class="p">,</span>
      <span class="n">count2</span><span class="p">,</span>
      <span class="n">increment2</span>
    <span class="p">}</span>
  <span class="p">}</span>
<span class="p">}</span>
</pre></div>
</div>
</section>
</section>
<section id="id10">
<h3><a class="toc-backref" href="#id27"><span class="section-number">10.5.4. </span>3.4 ref辅助操作的函数。</a><a class="headerlink" href="#id10" title="Permalink to this headline">¶</a></h3>
<p>Composition API也提供了一些其他的ref辅助操作的函数。</p>
<section id="isref">
<h4>1.isRef()<a class="headerlink" href="#isref" title="Permalink to this headline">¶</a></h4>
<p>用来判断某个值是否为ref创建出来的对象，在需要展开某个值可能是ref创建出来的对象时使用。示例代码如下：</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span>&lt;template&gt;
  &lt;p&gt; VUE3 新特性学习！！&lt;/p&gt;

  &lt;p&gt;{{count}}&lt;/p&gt;
  &lt;p&gt;isRef(count) ?{{ unwrappend }} .&lt;/p&gt;
&lt;/template&gt;

&lt;script&gt;
import {ref,isRef } from &#39;vue&#39;;
export default {
  setup() {
    const count = ref(1)
    const unwrappend = isRef(count) ? count.value: count
    return {
      count,
      unwrappend
    }
  }

}
&lt;/script&gt;

&lt;style scoped&gt;
&lt;/style&gt;
</pre></div>
</div>
</section>
<section id="torefs">
<h4>2.toRefs()<a class="headerlink" href="#torefs" title="Permalink to this headline">¶</a></h4>
<p>toRefs()函数可以将reactive创建出来的响应式对象转换为普通的对象，只不过这个对象上的每个属性节点都是ref类型的响应式数据。示例代码如下：</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span>&lt;template&gt;
  &lt;p&gt; VUE3 新特性学习！！&lt;/p&gt;

  &lt;p&gt;
    {{ count }}
    {{ value }}
  &lt;/p&gt;
&lt;/template&gt;

&lt;script&gt;
import {ref,reactive,toRefs } from &#39;vue&#39;;
export default {
  setup() {
    const state = reactive({
      count: 0,
      value: &#39;hello&#39;
    })
    return {
      ...toRefs(state)
    }
  }

}
&lt;/script&gt;

&lt;style scoped&gt;
&lt;/style&gt;
</pre></div>
</div>
</section>
<section id="toref">
<h4>3.toRef()<a class="headerlink" href="#toref" title="Permalink to this headline">¶</a></h4>
<p>toRef()函数为源响应式对象上的某个属性创建一个ref对象，二者内部操作的是同一个数据值，更新时二者同步。</p>
<p>与ref的区别是，使用toRef()函数复制的是一份新的数据单
独操作，更新时相互不影响，相当于深复制。</p>
<p>当要将某个prop的ref传递给某个复合函数时，toRef()很有用。</p>
<p>示例代码如下：</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span>&lt;template&gt;
  &lt;p&gt; VUE3 新特性学习！！&lt;/p&gt;

  &lt;p&gt;
    m1: {{ m1.a }}&lt;br&gt;
    m2 toRef: {{ m2 }}&lt;br&gt;
    m3 ref: {{ m3 }}&lt;br&gt;
  &lt;/p&gt;
  &lt;button @click=&quot;update1&quot;&gt;m1 change&lt;/button&gt;
  &lt;button @click=&quot;update2&quot;&gt;m2 toRef change&lt;/button&gt;
  &lt;button @click=&quot;update3&quot;&gt;m3 ref change&lt;/button&gt;
&lt;/template&gt;

&lt;script&gt;
import {ref,reactive,toRef } from &#39;vue&#39;;
export default {
  setup() {
    const m1 = reactive({
      a:1,
      b:2
    })
    const m2 = toRef(m1,&#39;a&#39;)
    const m3 = ref(m1.a)

    const update1 = () =&gt; {
      m1.a++   // m1改变时 m2也会改变
    }
    const update2 = () =&gt; {
      m2.value++  //  m2改变时 m1也会改变
    }
    const update3 = () =&gt; {
      // m1.a++   // m1改变时 m2也会改变
      // m2.value++  //  m2 改变时 m1也会改变
      m3.value++  // m3改变时 m1不会变
    }
    return {
      m1,
      m2,
      m3,
      update1,
      update2,
      update3
    }
  }

}
&lt;/script&gt;

&lt;style scoped&gt;
&lt;/style&gt;
</pre></div>
</div>
</section>
<section id="computed">
<h4>4.computed()计算属性<a class="headerlink" href="#computed" title="Permalink to this headline">¶</a></h4>
<p>computed()函数用来创建计算属性，返回值是一个ref的实例。创建只读的计算属性，示例代码如下：</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span>&lt;template&gt;
  &lt;p&gt; VUE3 新特性学习！！&lt;/p&gt;
  &lt;p&gt;
    {{count}}
    {{double}}
  &lt;/p&gt;

&lt;/template&gt;

&lt;script&gt;
import {ref,computed} from &#39;vue&#39;;

export default {
  setup() {
    const count = ref(0)
    const double = computed(() =&gt; count.value + 1)  //1
    // double ++ // 报错,只读
    return {
      count,
      double
    }

  }
}
&lt;/script&gt;

&lt;style scoped&gt;
&lt;/style&gt;
</pre></div>
</div>
<p>在使用computed（）函数期间，传入一个包含get()和set()函数的对象，可以得到一个可读可写的计算属性。示例代码如下：</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span>&lt;template&gt;
  &lt;p&gt; VUE3 新特性学习！！&lt;/p&gt;
  &lt;p&gt; computed 取值赋值 {{ count }}&lt;/p&gt;

&lt;/template&gt;

&lt;script&gt;
import {ref,computed} from &#39;vue&#39;;

export default {
  setup() {
    // 创建一个ref响应式数据
    const count = ref(1)
    // 创建一个computed()计算属性
    const plusOne = computed({
      // 取值函数
      get: () =&gt; count.value +1,

      // 赋值函数
      set: val =&gt; {
        count.value = val -1
      }
    })

    // 计算属性赋值，触发set函数
    plusOne.value = 9
    console.log(count.value)

    return {
      count
    }
    }

  }
&lt;/script&gt;

&lt;style scoped&gt;
&lt;/style&gt;
</pre></div>
</div>
</section>
</section>
<section id="id11">
<h3><a class="toc-backref" href="#id28"><span class="section-number">10.5.5. </span>3.5 Vue3中的响应式对象</a><a class="headerlink" href="#id11" title="Permalink to this headline">¶</a></h3>
<p>Vue 2中的data和Vue 3中的ref一样，都可以返回一个响应式对象，但是Vue
2中使用的是object.defineProperty()实现响应式的，这就导致Vue
2的响应式出现一些限制。</p>
<p>在Vue 2中新增一个响应式属性会变得很困难。</p>
<p>在Vue
2中，无法检测property的添加或者移除，对于已经创建的实例，Vue是不允许动态添加根级别的响应式属性的。如果要动态添加响应式对象的属性，可以使用Vue.set(object，propertyName，value)方法向嵌套对象中添加响应式属性，还可以使用vm.
$ set实例方法动态添加响应式属性，这也是全局Vue.set()方法的别名。</p>
<p>这种操作对于一个Vue的初学者来讲，很多时候需要小心翼翼地去判断到底什么情况下需要用$
set，什么情况下可以直接触发响应式。</p>
<p>这给初学者带来了很多困扰。在Vue 3中，这些问题都将成为过去式。</p>
<p>Vue 3采用了ES6的一个新特性，使用Proxy实现响应式。</p>
<p>Proxy对象用于定义基本操作的一个自定义行为，简单来讲，Proxy对象就是可以让开发者对一个JavaScript中一切合法对象的基本操作进行自定义，然后用自定义的操作去覆盖对象的一些基本操作。我们可以通过下面的两段代码来学习Vue
3中是如何使用Proxy进行优化的。</p>
<p>Vue 2中的响应式处理，示例代码如下：</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">Object</span><span class="o">.</span><span class="n">defineProperty</span><span class="p">(</span><span class="n">data</span><span class="p">,</span><span class="s1">&#39;count&#39;</span><span class="p">,{</span>
    <span class="n">get</span><span class="p">()</span> <span class="p">{},</span>
    <span class="nb">set</span><span class="p">()</span> <span class="p">{}</span>
<span class="p">})</span>
</pre></div>
</div>
<p>Vue 3中对于响应式的优化，示例代码如下：</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">new</span> <span class="n">Proxy</span><span class="p">(</span><span class="n">data</span><span class="p">,{</span>
    <span class="n">get</span><span class="p">(</span><span class="n">key</span><span class="p">)</span> <span class="p">{},</span>
    <span class="nb">set</span><span class="p">(</span><span class="n">key</span><span class="p">,</span><span class="n">value</span><span class="p">)</span> <span class="p">{}</span>
<span class="p">})</span>
</pre></div>
</div>
<p>通过上面两段代码可以看出，Proxy是在更高维度上进行一个属性拦截修改的，先来看一下Vue
2的代码示例。</p>
<p>对于给定的data对象，date对象中有一个count属性，需要根据具体的count去修改set()函数。</p>
<p>所以，Vue 2对于对象上的新增属性是无能为力的。</p>
<p>而Vue
3中使用Proxy进行拦截，这里无须知道具体的key是什么，拦截的是修改data上任意的key和读取data上任意的key的操作。所以，无论是已有的key还是新增的key都可以被拦截。</p>
<p>Proxy更加强大之处在于，除了getter和setter对属性的拦截外，还可以拦截更多的操作符。</p>
</section>
<section id="id12">
<h3><a class="toc-backref" href="#id29"><span class="section-number">10.5.6. </span>3.6 生命周期的改变</a><a class="headerlink" href="#id12" title="Permalink to this headline">¶</a></h3>
<p>在Vue 3中的生命周期和在Vue
2中的生命周期的用法是一样的。所谓生命周期，就是一个组件从创建到销毁的全过程，会暴露出一系列的钩子函数供开发者在对应阶段进行相关的操作。</p>
<p>除了Vue 2中已有的一部分生命周期钩子，Vue
3还增加了一些新的生命周期，可以直接导入on×××一族的函数来注册生命周期钩子。示例代码如下：</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="o">&lt;</span><span class="n">template</span><span class="o">&gt;</span>
  <span class="o">&lt;</span><span class="n">div</span> <span class="nb">id</span><span class="o">=</span><span class="s2">&quot;app&quot;</span><span class="o">&gt;&lt;/</span><span class="n">div</span><span class="o">&gt;</span>
<span class="o">&lt;/</span><span class="n">template</span><span class="o">&gt;</span>

<span class="o">&lt;</span><span class="n">script</span><span class="o">&gt;</span>
<span class="o">//</span> <span class="mf">1.</span> <span class="n">从</span> <span class="n">vue</span> <span class="n">中引入</span> <span class="n">多个生命周期函数</span>
<span class="kn">import</span> <span class="p">{</span><span class="n">onBeforeMount</span><span class="p">,</span> <span class="n">onMounted</span><span class="p">,</span> <span class="n">onBeforeUpdate</span><span class="p">,</span> <span class="n">onUpdated</span><span class="p">,</span> <span class="n">onBeforeUnmount</span><span class="p">,</span> <span class="n">unMounted</span><span class="p">}</span> <span class="kn">from</span> <span class="s1">&#39;vue&#39;</span>
<span class="n">export</span> <span class="n">default</span> <span class="p">{</span>
  <span class="n">name</span><span class="p">:</span> <span class="s1">&#39;App&#39;</span><span class="p">,</span>
  <span class="n">setup</span><span class="p">()</span> <span class="p">{</span>
      <span class="n">onBeforeMount</span><span class="p">(()</span> <span class="o">=&gt;</span> <span class="p">{</span>
          <span class="o">//</span> <span class="n">在挂载前执行某些代码</span>
      <span class="p">})</span>

      <span class="n">onMounted</span><span class="p">(()</span> <span class="o">=&gt;</span> <span class="p">{</span>
          <span class="o">//</span> <span class="n">在挂载后执行某些代码</span>
      <span class="p">})</span>

      <span class="n">onBeforeUpdate</span><span class="p">(()</span> <span class="o">=&gt;</span> <span class="p">{</span>
          <span class="o">//</span> <span class="n">在更新前前执行某些代码</span>
      <span class="p">})</span>

      <span class="n">onUpdated</span><span class="p">(()</span> <span class="o">=&gt;</span> <span class="p">{</span>
          <span class="o">//</span> <span class="n">在更新后执行某些代码</span>
      <span class="p">})</span>

      <span class="n">onBeforeUnmount</span><span class="p">(()</span> <span class="o">=&gt;</span> <span class="p">{</span>
          <span class="o">//</span> <span class="n">在组件销毁前执行某些代码</span>
      <span class="p">})</span>

      <span class="n">unMounted</span><span class="p">(()</span> <span class="o">=&gt;</span> <span class="p">{</span>
          <span class="o">//</span> <span class="n">在组件销毁后执行某些代码</span>
      <span class="p">})</span>

      <span class="k">return</span> <span class="p">{}</span>
  <span class="p">}</span>

<span class="p">}</span>
<span class="o">&lt;/</span><span class="n">script</span><span class="o">&gt;</span>
</pre></div>
</div>
<p>Vue
3的生命周期钩子函数只能在setup()期间同步使用，因为它们依赖于内部的全局状态来定位当前组件实例，不在当前组件下调用这些函数会抛出一个错误。</p>
<p>组件实例上下文也是在生命周期钩子同步执行期间设置的，因此，在卸载组件时，在生命周期钩子内部同步创建的侦听器和计算状态也将自动删除。</p>
<p>Vue 3中与Vue 2的生命周期相对应的组合式API如下。</p>
<p>下面放上一张变化图来简单了解一下</p>
<table class="docutils align-default">
<colgroup>
<col style="width: 46%" />
<col style="width: 54%" />
</colgroup>
<thead>
<tr class="row-odd"><th class="head"><p>Vue2</p></th>
<th class="head"><p>Vue3</p></th>
</tr>
</thead>
<tbody>
<tr class="row-even"><td><p>beforeCreate</p></td>
<td><p>setup</p></td>
</tr>
<tr class="row-odd"><td><p>created</p></td>
<td><p>setup</p></td>
</tr>
<tr class="row-even"><td><p>beforeMount</p></td>
<td><p>onBeforeMount</p></td>
</tr>
<tr class="row-odd"><td><p>mounted</p></td>
<td><p>onMounted</p></td>
</tr>
<tr class="row-even"><td><p>beforeUpdate</p></td>
<td><p>onBeforeUpdate</p></td>
</tr>
<tr class="row-odd"><td><p>updated</p></td>
<td><p>onUpdated</p></td>
</tr>
<tr class="row-even"><td><p>beforeDestory</p></td>
<td><p>onBeforeUnmount</p></td>
</tr>
<tr class="row-odd"><td><p>destoryed</p></td>
<td><p>onUnmounted</p></td>
</tr>
<tr class="row-even"><td><p>errorCaptured</p></td>
<td><p>onErrorCaptured</p></td>
</tr>
</tbody>
</table>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span>setup 包含的生命周期
onBeforeMount——挂载开始前调用
onMounted——挂载后调用
onBeforeUpdate——当响应数据改变，且重新渲染前调用
onUpdated——重新渲染后调用
onBeforeUnmount——Vue实例销毁前调用
onUnmounted——实例销毁后调用
onActivated——当keep-alive组件被激活时调用
onDeactivated——当keep-alive组件取消激活时调用
onErrorCaptured——从子组件中捕获错误时调用
</pre></div>
</div>
<p>vue2的生命周期函数如下：</p>
<img alt="../_images/image-20220823095016970.png" src="../_images/image-20220823095016970.png" />
<p>vue3的生命周期函数</p>
<img alt="../_images/image-20220823095248771.png" src="../_images/image-20220823095248771.png" />
<p>Vue 2生命周期的初创期钩子beforeCreate和created，在Vue
3中用setup()替代了。</p>
<p>除了和2.x生命周期等效项之外，组合式API还提供了以下调试钩子函数。</p>
<p>（1）onRenderTracked()。</p>
<p>（2）onRenderTriggered()。</p>
<p>两个钩子函数都接收一个DebuggerEvent，与watchEffect参数选项中的onTrack和onTrigger类似。示例代码如下：</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">export</span> <span class="n">default</span> <span class="p">{</span>
  <span class="n">onRenderTracked</span><span class="p">(</span><span class="n">e</span><span class="p">){</span>
    <span class="n">debugger</span>
  <span class="p">},</span>
  <span class="n">setup</span><span class="p">()</span> <span class="p">{</span>
  <span class="p">}</span>
<span class="p">}</span>
<span class="o">&lt;/</span><span class="n">script</span><span class="o">&gt;</span>
</pre></div>
</div>
</section>
<section id="watch">
<h3><a class="toc-backref" href="#id30"><span class="section-number">10.5.7. </span>3.7 watch()侦测变化</a><a class="headerlink" href="#watch" title="Permalink to this headline">¶</a></h3>
<p>watch()函数用来监视某些数据项的变化，从而触发某些特定的操作，下面这个案例会实时监听count值的变化。</p>
<p>示例代码如下：</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="o">&lt;</span><span class="n">script</span><span class="o">&gt;</span>
<span class="kn">import</span> <span class="p">{</span><span class="n">ref</span><span class="p">,</span> <span class="n">watch</span><span class="p">}</span> <span class="kn">from</span> <span class="s2">&quot;vue&quot;</span><span class="p">;</span>
<span class="n">export</span> <span class="n">default</span> <span class="p">{</span>
    <span class="n">setup</span><span class="p">()</span> <span class="p">{</span>
      <span class="n">const</span> <span class="n">count</span> <span class="o">=</span> <span class="n">ref</span><span class="p">(</span><span class="mi">1</span><span class="p">)</span>
      <span class="n">watch</span><span class="p">(()</span> <span class="o">=&gt;</span><span class="p">{</span>
        <span class="n">console</span><span class="o">.</span><span class="n">log</span><span class="p">(</span><span class="n">count</span><span class="o">.</span><span class="n">value</span><span class="p">,</span><span class="s1">&#39;value&#39;</span><span class="p">)</span>
      <span class="p">})</span>
      <span class="o">//</span> <span class="n">每隔1s执行一次</span>
      <span class="n">setInterval</span><span class="p">(()</span> <span class="o">=&gt;</span><span class="p">{</span>
        <span class="n">count</span><span class="o">.</span><span class="n">value</span><span class="o">++</span>
      <span class="p">},</span><span class="mi">100</span><span class="p">)</span>

      <span class="k">return</span> <span class="p">{</span>
        <span class="n">count</span>
      <span class="p">}</span>
    <span class="p">}</span>
<span class="p">}</span>
<span class="o">&lt;/</span><span class="n">script</span><span class="o">&gt;</span>
</pre></div>
</div>
<p>watch()还可以监听指定的数据源，例如监听reactive()的数据变化。</p>
<p>示例代码如下：</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span>&lt;template&gt;
  &lt;p&gt; VUE3 新特性学习！！&lt;/p&gt;
  &lt;p&gt;生命周期的改变&lt;/p&gt;
&lt;/template&gt;

&lt;script&gt;
import {reactive, ref, watch} from &quot;vue&quot;;

export default {
  setup() {
    const state = reactive({
      count: 0
    })

    watch(() =&gt; state.count,(count,prevCount) =&gt;{
      console.log(count,prevCount)      // 变化后的值及变化前的值
    })
    // 每隔1s执行一次
    setInterval(() =&gt; {
      state.count++
    }, 100)

    return {
      state
    }
  }
}
&lt;/script&gt;

&lt;style scoped&gt;
&lt;/style&gt;
</pre></div>
</div>
<p>watch()用于监听ref类型的数据变化，示例代码如下：</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="o">&lt;</span><span class="n">script</span><span class="o">&gt;</span>
<span class="kn">import</span> <span class="p">{</span><span class="n">ref</span><span class="p">,</span> <span class="n">watch</span><span class="p">}</span> <span class="kn">from</span> <span class="s2">&quot;vue&quot;</span><span class="p">;</span>

<span class="n">export</span> <span class="n">default</span> <span class="p">{</span>
  <span class="n">setup</span><span class="p">()</span> <span class="p">{</span>
    <span class="n">const</span> <span class="n">count</span> <span class="o">=</span> <span class="n">ref</span><span class="p">(</span><span class="mi">1</span><span class="p">)</span>
    <span class="n">watch</span><span class="p">(</span><span class="n">count</span><span class="p">,(</span><span class="n">count</span><span class="p">,</span><span class="n">prevCount</span><span class="p">)</span> <span class="o">=&gt;</span><span class="p">{</span>
      <span class="n">console</span><span class="o">.</span><span class="n">log</span><span class="p">(</span><span class="n">count</span><span class="p">,</span><span class="n">prevCount</span><span class="p">)</span>
    <span class="p">})</span>
    <span class="o">//</span> <span class="n">每隔1s执行一次</span>
    <span class="n">setInterval</span><span class="p">(()</span> <span class="o">=&gt;</span><span class="p">{</span>
      <span class="n">count</span><span class="o">.</span><span class="n">value</span><span class="o">++</span>
    <span class="p">},</span><span class="mi">100</span><span class="p">)</span>

    <span class="k">return</span> <span class="p">{</span>
      <span class="n">count</span>
    <span class="p">}</span>
  <span class="p">}</span>
<span class="p">}</span>
<span class="o">&lt;/</span><span class="n">script</span><span class="o">&gt;</span>
</pre></div>
</div>
<p>在setup()函数内创建的watch()监视，会在当前组件被销毁的时候自动停止。如果想要明确停止某个监视，可以调用watch()函数的返回值。示例代码如下：</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span>&lt;script&gt;
import {ref, watch} from &quot;vue&quot;;
export default {
  setup() {
    const count = ref(1)
    const stop = watch(() =&gt;{
      /* ...   */
    })

    // 调用停止函数，清除对应的监视
    stop()
    return {
      count
    }
  }
}
&lt;/script&gt;
</pre></div>
</div>
</section>
<section id="vue3typescript">
<h3><a class="toc-backref" href="#id31"><span class="section-number">10.5.8. </span>3.8 Vue3更好地支持TypeScript</a><a class="headerlink" href="#vue3typescript" title="Permalink to this headline">¶</a></h3>
<p>Vue 2依赖于this上下文对象向外暴露属性，但是在设计Vue
2的API时，并没有考虑到与TypeScript集成。如果在Vue
2中想要使用TypeScript语法，需要使用vueclass或者vue
extends的方式来集成对TypeScript的支持。</p>
<p>到了Vue
3，Vue官方团队推出了一个新的方式定义component，这个方式称为defineComponent。示例代码如下：</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span>&lt;template&gt;
  &lt;p&gt; VUE3 新特性学习！！&lt;/p&gt;
&lt;/template&gt;

&lt;script&gt;
import {defineComponent} from &quot;vue&quot;;
export default defineComponent({
  setup(){
    function demo(str) {
      console.log(str)
    }
    return {
      demo
    }

  }

})
&lt;/script&gt;

&lt;style scoped&gt;
&lt;/style&gt;
</pre></div>
</div>
</section>
<section id="teleport">
<h3><a class="toc-backref" href="#id32"><span class="section-number">10.5.9. </span>3.9 Teleport传送门</a><a class="headerlink" href="#teleport" title="Permalink to this headline">¶</a></h3>
<p><a class="reference external" href="https://cn.vuejs.org/guide/built-ins/teleport.html">https://cn.vuejs.org/guide/built-ins/teleport.html</a></p>
</section>
<section id="suspense">
<h3><a class="toc-backref" href="#id33"><span class="section-number">10.5.10. </span>3.10 Suspense异步请求</a><a class="headerlink" href="#suspense" title="Permalink to this headline">¶</a></h3>
<p><a class="reference external" href="https://cn.vuejs.org/guide/built-ins/suspense.html">https://cn.vuejs.org/guide/built-ins/suspense.html</a></p>
</section>
<section id="api">
<h3><a class="toc-backref" href="#id34"><span class="section-number">10.5.11. </span>3.11 全局API修改</a><a class="headerlink" href="#api" title="Permalink to this headline">¶</a></h3>
<p>Vue
3中增加了createApp这个新的全局API，调用createApp返回一个应用实例。示例代码如下：</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span>import { createApp } from &#39;vue&#39;
import App from &#39;./App.vue&#39;
import router from &#39;./router&#39;
import store from &#39;./store&#39;
import ElementPlus from &#39;element-plus&#39;
import &#39;element-plus/dist/index.css&#39;
import axios from &#39;axios&#39;

const app = createApp({})
app.config.globalProperties.$axios = axios

createApp(App).use(store).use(router).use(ElementPlus).mount(&#39;#app&#39;)
</pre></div>
</div>
<p>Vue 2全局API与Vue 3实例API对照表</p>
<img alt="../_images/image-20220727145453029.png" src="../_images/image-20220727145453029.png" />
<p>所有其他不全局改变行为的全局API现在被命名为exports。</p>
<p>vue2与vue3常用操作映射关系</p>
<p><a class="reference external" href="https://blog.csdn.net/yifangshikong/article/details/124355335">https://blog.csdn.net/yifangshikong/article/details/124355335</a></p>
<p>应用实例 API参考如下文档</p>
<p><a class="reference external" href="https://cn.vuejs.org/api/application.html">https://cn.vuejs.org/api/application.html</a></p>
<p>快速使用Vue3最新的15个常用API（1W5+字详解，建议收藏）</p>
<p><a class="reference external" href="https://blog.csdn.net/l_ppp/article/details/109718767">https://blog.csdn.net/l_ppp/article/details/109718767</a></p>
</section>
</section>
<section id="id13">
<h2><a class="toc-backref" href="#id35"><span class="section-number">10.6. </span>7 vue3实战笔记 | 快速入门</a><a class="headerlink" href="#id13" title="Permalink to this headline">¶</a></h2>
<p><a class="reference external" href="https://juejin.cn/post/6909632635665039367">https://juejin.cn/post/6909632635665039367</a></p>
<ul class="simple">
<li><p><a class="reference external" href="https://juejin.cn/post/6909247394904702984">【Vue3 官方教程】🎄 万字笔记 |
同步导学视频</a></p></li>
<li><p><a class="reference external" href="https://github.com/su37josephxia/vue3-study">vue3-study</a></p></li>
<li><p><a class="reference external" href="https://www.yuque.com/nxtt7g/kompdt">Vue-Mastery 学习笔记</a></p></li>
<li><p>[&#64;vue/composition-api - 用于提供组合式 API 的 Vue 2
插件](<a class="reference external" href="https://github.com/vuejs/composition-api/blob/master/README.zh-CN.md">https://github.com/vuejs/composition-api/blob/master/README.zh-CN.md</a>)</p></li>
<li><p>[&#64;vue/composition-api
速成课](<a class="reference external" href="https://blog.csdn.net/frontend_frank/article/details/108786784">https://blog.csdn.net/frontend_frank/article/details/108786784</a>)</p></li>
<li><p><a class="reference external" href="https://github.com/vuejs/vue-class-component/tree/next">Vue Class Component v8 - The next Vue Class Component for Vue
v3.</a></p></li>
<li><p><a class="reference external" href="https://juejin.cn/post/6909632635665039367">Vue3 实战笔记</a></p></li>
<li><p><a class="reference external" href="https://juejin.cn/post/6897030228867022856">快速使用 Vue3 最新的 15 个常用
API</a></p></li>
</ul>
</section>
<section id="vue3-0">
<h2><a class="toc-backref" href="#id36"><span class="section-number">10.7. </span>8.全面总结Vue3.0 的新特性</a><a class="headerlink" href="#vue3-0" title="Permalink to this headline">¶</a></h2>
<p><a class="reference external" href="https://blog.csdn.net/qq_22182989/article/details/126094572">https://blog.csdn.net/qq_22182989/article/details/126094572</a></p>
</section>
</section>


           </div>
          </div>
          <footer><div class="rst-footer-buttons" role="navigation" aria-label="Footer">
        <a href="09.%E6%9C%8D%E5%8A%A1%E5%99%A8%E7%AB%AF%E6%B8%B2%E6%9F%93.html" class="btn btn-neutral float-left" title="9. 服务器端渲染" accesskey="p" rel="prev"><span class="fa fa-arrow-circle-left" aria-hidden="true"></span> Previous</a>
        <a href="11.TypeScript%E5%85%A5%E9%97%A8.html" class="btn btn-neutral float-right" title="11. TypeScript入门" accesskey="n" rel="next">Next <span class="fa fa-arrow-circle-right" aria-hidden="true"></span></a>
    </div>

  <hr/>

  <div role="contentinfo">
    <p>&#169; Copyright 2019, huxiaojian.</p>
  </div>

  Built with <a href="https://www.sphinx-doc.org/">Sphinx</a> using a
    <a href="https://github.com/readthedocs/sphinx_rtd_theme">theme</a>
    provided by <a href="https://readthedocs.org">Read the Docs</a>.
   

</footer>
        </div>
      </div>
    </section>
  </div>
  <script>
      jQuery(function () {
          SphinxRtdTheme.Navigation.enable(true);
      });
  </script> 

</body>
</html>