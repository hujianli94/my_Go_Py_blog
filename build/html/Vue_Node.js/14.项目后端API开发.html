<!DOCTYPE html>
<html class="writer-html5" lang="en" >
<head>
  <meta charset="utf-8" /><meta name="generator" content="Docutils 0.17: http://docutils.sourceforge.net/" />

  <meta name="viewport" content="width=device-width, initial-scale=1.0" />
  <title>14. 项目后端API开发 &mdash; 运维开发修炼之路</title>
      <link rel="stylesheet" href="../_static/pygments.css" type="text/css" />
      <link rel="stylesheet" href="../_static/css/theme.css" type="text/css" />
  <!--[if lt IE 9]>
    <script src="../_static/js/html5shiv.min.js"></script>
  <![endif]-->
  
        <script data-url_root="../" id="documentation_options" src="../_static/documentation_options.js"></script>
        <script src="../_static/jquery.js"></script>
        <script src="../_static/underscore.js"></script>
        <script src="../_static/doctools.js"></script>
    <script src="../_static/js/theme.js"></script>
    <link rel="index" title="Index" href="../genindex.html" />
    <link rel="search" title="Search" href="../search.html" />
    <link rel="next" title="15. 通用API开发" href="15.%E9%80%9A%E7%94%A8API%E5%BC%80%E5%8F%91.html" />
    <link rel="prev" title="13. 项目策划和功能设计" href="13.%E9%A1%B9%E7%9B%AE%E7%AD%96%E5%88%92%E5%92%8C%E5%8A%9F%E8%83%BD%E8%AE%BE%E8%AE%A1.html" /> 
</head>

<body class="wy-body-for-nav"> 
  <div class="wy-grid-for-nav">
    <nav data-toggle="wy-nav-shift" class="wy-nav-side">
      <div class="wy-side-scroll">
        <div class="wy-side-nav-search" >
            <a href="../index.html" class="icon icon-home"> 小健_Python_go_Devops
            <img src="../_static/python_go.png" class="logo" alt="Logo"/>
          </a>
              <div class="version">
                2.0
              </div>
<div role="search">
  <form id="rtd-search-form" class="wy-form" action="../search.html" method="get">
    <input type="text" name="q" placeholder="Search docs" />
    <input type="hidden" name="check_keywords" value="yes" />
    <input type="hidden" name="area" value="default" />
  </form>
</div>
        </div><div class="wy-menu wy-menu-vertical" data-spy="affix" role="navigation" aria-label="Navigation menu">
              <ul class="current">
<li class="toctree-l1"><a class="reference internal" href="../Go/index.html">Go语言学习</a></li>
<li class="toctree-l1"><a class="reference internal" href="../Go_vs_Python/index.html">Go vs Python</a></li>
<li class="toctree-l1"><a class="reference internal" href="../Python/index.html">Python全栈系列</a></li>
<li class="toctree-l1"><a class="reference internal" href="../Python%E6%B5%8B%E8%AF%95%E5%BC%80%E5%8F%91%E5%85%A5%E9%97%A8%E4%B8%8E%E5%AE%9E%E8%B7%B5/index.html">Python测试开发入门与实践</a></li>
<li class="toctree-l1"><a class="reference internal" href="../Vue/index.html">Vue.js企业开发实战</a></li>
<li class="toctree-l1 current"><a class="reference internal" href="index.html">Vue.js+Node.js开发实战</a><ul class="current">
<li class="toctree-l2"><a class="reference internal" href="01.%E5%BC%80%E5%8F%91%E4%B8%80%E4%B8%AA%E7%BD%91%E7%AB%99%E7%9A%84%E5%87%86%E5%A4%87.html">1. 开发一个网站的准备</a></li>
<li class="toctree-l2"><a class="reference internal" href="02.Nodejs_vue%E5%9F%BA%E7%A1%80.html">2. Nodejs+vue基础</a></li>
<li class="toctree-l2"><a class="reference internal" href="03.%E9%A1%B9%E7%9B%AE%E5%BC%80%E5%8F%91%E5%87%86%E5%A4%87.html">3. 项目开发准备</a></li>
<li class="toctree-l2"><a class="reference internal" href="04.%E9%A1%B9%E7%9B%AE%E5%90%8E%E5%8F%B0%E6%8A%80%E6%9C%AFExpress.html">4. 项目后台技术Express</a></li>
<li class="toctree-l2"><a class="reference internal" href="05.Vue.js%E5%BC%80%E5%8F%91%E5%9F%BA%E7%A1%80.html">5. Vue.js开发基础</a></li>
<li class="toctree-l2"><a class="reference internal" href="06.Vue.js%E7%9A%84%E7%94%9F%E5%91%BD%E5%91%A8%E6%9C%9F.html">6. Vue的生命周期</a></li>
<li class="toctree-l2"><a class="reference internal" href="07.Vue.js%E7%9A%84%E6%A8%A1%E6%9D%BF%E8%AF%AD%E6%B3%95.html">7. Vue.js的模板语法</a></li>
<li class="toctree-l2"><a class="reference internal" href="08.Vue.js%E7%9A%84%E7%BB%84%E4%BB%B6%E5%8C%96.html">8. Vue.js的组件化</a></li>
<li class="toctree-l2"><a class="reference internal" href="09.Vue.js%E7%9A%84vue-router%E5%BA%93.html">9. Vue.js的vue-router库</a></li>
<li class="toctree-l2"><a class="reference internal" href="10.Vue.js%E7%9A%84%E7%8A%B6%E6%80%81%E7%AE%A1%E7%90%86%E5%BA%93Vuex%E5%92%8CPinia.html">10. Vue.js的状态管理库Vuex和Pinia</a></li>
<li class="toctree-l2"><a class="reference internal" href="11.Vue-UI%E5%BA%93.html">11. Vue-UI库</a></li>
<li class="toctree-l2"><a class="reference internal" href="12.%E9%A1%B9%E7%9B%AE%E9%9C%80%E6%B1%82%E5%88%86%E6%9E%90%E5%92%8C%E5%8A%9F%E8%83%BD%E8%AF%B4%E6%98%8E.html">12. 项目需求分析和功能说明</a></li>
<li class="toctree-l2"><a class="reference internal" href="13.%E9%A1%B9%E7%9B%AE%E7%AD%96%E5%88%92%E5%92%8C%E5%8A%9F%E8%83%BD%E8%AE%BE%E8%AE%A1.html">13. 项目策划和功能设计</a></li>
<li class="toctree-l2 current"><a class="current reference internal" href="#">14. 项目后端API开发</a><ul>
<li class="toctree-l3"><a class="reference internal" href="#id1">14.1. 1.开发前的准备工作</a></li>
<li class="toctree-l3"><a class="reference internal" href="#id2">14.2. 2.初始化项目</a></li>
<li class="toctree-l3"><a class="reference internal" href="#id3">14.3. 3.连接数据库</a></li>
<li class="toctree-l3"><a class="reference internal" href="#id4">14.4. 4.配置服务应用列表</a></li>
</ul>
</li>
<li class="toctree-l2"><a class="reference internal" href="15.%E9%80%9A%E7%94%A8API%E5%BC%80%E5%8F%91.html">15. 通用API开发</a></li>
<li class="toctree-l2"><a class="reference internal" href="16.%E7%94%A8%E6%88%B7%E6%9D%83%E9%99%90%E7%9B%B8%E5%85%B3API%E5%BC%80%E5%8F%91.html">16. 用户权限相关API开发</a></li>
<li class="toctree-l2"><a class="reference internal" href="17.%E5%90%8E%E5%8F%B0%E7%AE%A1%E7%90%86%E7%9B%B8%E5%85%B3API%E5%BC%80%E5%8F%91.html">17. 后台管理相关API开发</a></li>
<li class="toctree-l2"><a class="reference internal" href="18.%E5%B0%8F%E7%BB%93.html">18. 小结</a></li>
<li class="toctree-l2"><a class="reference internal" href="19.%E5%89%8D%E7%AB%AF%E9%A1%B5%E9%9D%A2%E5%BC%80%E5%8F%91.html">19. 前端页面开发</a></li>
<li class="toctree-l2"><a class="reference internal" href="20.%E4%B8%BB%E8%A6%81%E9%A1%B5%E9%9D%A2%E7%9A%84%E5%BC%80%E5%8F%91.html">20. 主要页面的开发</a></li>
</ul>
</li>
</ul>

        </div>
      </div>
    </nav>

    <section data-toggle="wy-nav-shift" class="wy-nav-content-wrap"><nav class="wy-nav-top" aria-label="Mobile navigation menu" >
          <i data-toggle="wy-nav-top" class="fa fa-bars"></i>
          <a href="../index.html">小健_Python_go_Devops</a>
      </nav>

      <div class="wy-nav-content">
        <div class="rst-content">
          <div role="navigation" aria-label="Page navigation">
  <ul class="wy-breadcrumbs">
      <li><a href="../index.html" class="icon icon-home"></a> &raquo;</li>
          <li><a href="index.html">Vue.js+Node.js开发实战</a> &raquo;</li>
      <li><span class="section-number">14. </span>项目后端API开发</li>
      <li class="wy-breadcrumbs-aside">
            <a href="../_sources/Vue_Node.js/14.项目后端API开发.rst.txt" rel="nofollow"> View page source</a>
      </li>
  </ul>
  <hr/>
</div>
          <div role="main" class="document" itemscope="itemscope" itemtype="http://schema.org/Article">
           <div itemprop="articleBody">
             
  <div class="contents topic" id="contents">
<p class="topic-title">Contents</p>
<ul class="simple">
<li><p><a class="reference internal" href="#api" id="id5">项目后端API开发</a></p>
<ul>
<li><p><a class="reference internal" href="#id1" id="id6">1.开发前的准备工作</a></p></li>
<li><p><a class="reference internal" href="#id2" id="id7">2.初始化项目</a></p></li>
<li><p><a class="reference internal" href="#id3" id="id8">3.连接数据库</a></p></li>
<li><p><a class="reference internal" href="#id4" id="id9">4.配置服务应用列表</a></p></li>
</ul>
</li>
</ul>
</div>
<section id="api">
<h1><a class="toc-backref" href="#id5"><span class="section-number">14. </span>项目后端API开发</a><a class="headerlink" href="#api" title="Permalink to this headline">¶</a></h1>
<p>本章将开发上一章介绍的项目，并且会逐一实现所有的后端功能。</p>
<p>另外，本章将使用之前介绍过的Postman进行接口API的请求测试。</p>
<p>本章涉及的知识点如下：</p>
<ul class="simple">
<li><p>开发一个完整的小型项目后端；</p></li>
<li><p>Node.js与MySQL及Redis的连接和使用；</p></li>
<li><p>在项目中编写完成需求的接口。</p></li>
</ul>
<section id="id1">
<h2><a class="toc-backref" href="#id6"><span class="section-number">14.1. </span>1.开发前的准备工作</a><a class="headerlink" href="#id1" title="Permalink to this headline">¶</a></h2>
<p>本节使用Express新建项目，并且配置好数据库连接，为之后的API开发做好准备。</p>
<blockquote>
<div><p>注意：在使用Express开发时，除非使用第三方工具，否则Express不会自动根据更改进行热更新，而需要手动重启服务器才能看到更改后的内容。</p>
</div></blockquote>
</section>
<section id="id2">
<h2><a class="toc-backref" href="#id7"><span class="section-number">14.2. </span>2.初始化项目</a><a class="headerlink" href="#id2" title="Permalink to this headline">¶</a></h2>
<p>首先保证本机已经安装了Express，使用如下命令生成一个新的项目：</p>
<div class="highlight-shell notranslate"><div class="highlight"><pre><span></span>$ express --no-view server
</pre></div>
</div>
<p>本项目中所有的后端内容都使用接口方式，不需要任何的模板引擎，因此使用–no-
view参数初始化一个不需要模板引擎的项目。</p>
<p>根据提示进入项目文件夹，使用如下命令安装完整的项目依赖包并尝试启动，效果如图</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span>$ cd server
$ cnpm install
$ SET DEBUG=server:* &amp; npm start
</pre></div>
</div>
</section>
<section id="id3">
<h2><a class="toc-backref" href="#id8"><span class="section-number">14.3. </span>3.连接数据库</a><a class="headerlink" href="#id3" title="Permalink to this headline">¶</a></h2>
<p>使用如下命令安装Redis依赖包，Redis的依赖包会自动添加到Express项目中，并且可以在Express中引用。</p>
<div class="highlight-shell notranslate"><div class="highlight"><pre><span></span>$ npm install redis -save
</pre></div>
</div>
<blockquote>
<div><p>注意：如果使用的是Express
5.0及以上版本，部分写法可能出现变动，根据官方文档进行微调即可。在Node.js中，Redis包被编写为支持异步的形式，该包提供了基本的数据库操作，这里需要在该项目文件中进行统一处理。首先在项目文件夹中新建config文件夹，用来存放所有的配置文件，然后进行以下配置操作：</p>
</div></blockquote>
<p>（1）在config文件夹中新建JavaScript文件，命名为db.js，用于存放Redis数据库的配置。代码如下：</p>
<div class="highlight-javascript notranslate"><div class="highlight"><pre><span></span><span class="nx">exports</span><span class="p">.</span><span class="nx">redisConfig</span> <span class="o">=</span> <span class="p">{</span><span class="nx">host</span><span class="o">:</span> <span class="s1">&#39;192.168.1.107&#39;</span><span class="p">,</span> <span class="nx">port</span><span class="o">:</span> <span class="s1">&#39;6379&#39;</span><span class="p">,</span> <span class="nx">password</span><span class="o">:</span> <span class="s2">&quot;123456&quot;</span><span class="p">,</span><span class="nx">ttl</span><span class="o">:</span> <span class="mf">5</span> <span class="o">*</span> <span class="mf">60</span> <span class="o">*</span> <span class="mf">1000</span><span class="p">}</span>
</pre></div>
</div>
<p>说明：配置文件不一定必须要使用JavaScript文件形式，也可以使用专门用于存储配置的其他格式，引用时注意编写文件格式相应的解析。</p>
<p>（2）在项目文件的根目录下新建util文件夹，放置所有工具的JavaScript方法，数据库连接方法也存放在该文件夹中。</p>
<p>（3）新建一个redisDB.js文件，在该文件中连接数据库，并且对数据库提供的方法进行一些改写和封装。需要注意的是，对于Redis，我们尽可能只使用两个相关的操作方法，一个是set，用于数据的存储和改变，另一个是get，用于数据的获取。redisDB.js文件的代码如下：</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span>let redis = require(&quot;redis&quot;);
//获取到数据库的配置
const {redisConfig} = require(&quot;../config/db&quot;)
//获取redis连接
const redis_client = redis.createClient(redisConfig);
//连接成功
redis_client.on(&quot;connect&quot;, () =&gt; {
    console.log(&quot;连接成功&quot;)
})
//错误处理
redis_client.on(&quot;error&quot;, (err) =&gt; {
    console.log(err);
});
redis = {};

//根据模式获得全部键
keys = async (cursor, re, count) =&gt; {
    let getTempKeys = await new Promise((resolve) =&gt; {
        //从连接中获得到该值，并且返回
        redis_client.scan([cursor, &quot;MATCH&quot;, re, &quot;COUNT&quot;, count], (err, res) =&gt; {
            console.log(err)
            return resolve(res);
        });
    });
    return getTempKeys;
}
redis.scan = async (re, cursor = 0, count = 100) =&gt; {
    return await keys(cursor, re, count)
}

//set该值进入数据库
redis.set = (key, value) =&gt; {
    // 将所有对象转换为Json字符串进行保存
    // 需要注意的是如果该字符串过大，可能会导致性能下降
    value = JSON.stringify(value);
    return redis_client.set(key, value, (err) =&gt; {
        if (err) {
            console.log(err);
        }
    });
};
// 获得text，在get时可以使用then调用
text = async (key) =&gt; {
    let getTempValue = await new Promise((resolve) =&gt; {
        //从连接中获得到该值，并且返回
        redis_client.get(key, (err, res) =&gt; {
            return resolve(res);
        });
    });
    //将该值转化为本身的对象，并且返回
    getTempValue = JSON.parse(getTempValue)
    return getTempValue;
}
//返回获得的值
redis.get = async (key) =&gt; {
    return await text(key);
}

//设置key的过期时间
redis.expire = (key, ttl) =&gt; {
    redis_client.expire(key, parseInt(ttl))
}

//获取自增id
id = async (key) =&gt; {
    console.log(&quot;查找&quot; + key)
    let id = await new Promise((resolve =&gt; {
        redis_client.incr(key, (err, res) =&gt; {
            console.log(res)
            return resolve(res)
        })
    }))
    console.log(id)
    return id
}
redis.incr = async (key) =&gt; {
    return await id(key)
}
//有序集合
//新增有序集合(键名，成员和分值)
redis.zadd = (key, member, num) =&gt; {
    member = JSON.stringify(member)
    redis_client.zadd(key, num, member, (err) =&gt; {
        if (err) {
            console.log(err)
        }
    })
}
//获取一定范围内的元素
tempData = async (key, min, max) =&gt; {
    let tData = await new Promise((resolve =&gt; {
        redis_client.zrevrange([key, min, max, &#39;WITHSCORES&#39;], (err, res) =&gt; {
            return resolve(res)
        })
    }))
    //同时获得了分值，所以需要进行转化为对象
    let oData = []
    //构造
    for (let i = 0; i &lt; tData.length; i = i + 2) {
        console.log(tData[i])
        oData.push({member: JSON.parse(tData[i]), score: tData[i + 1]})
    }
    return oData
}

redis.zrevrange = async (key, min = 0, max = -1) =&gt; {
    return tempData(key, min, max)
}

//有序集合的自增操作
redis.zincrby = (key, member, NUM = 1) =&gt; {
    member = JSON.stringify(member)
    redis_client.zincrby(key, NUM, member, (err) =&gt; {
        if (err) console.log(err)
    })
}

//有序集合通过member获取其score值
tempZscore = async (key, member) =&gt; {
    member = JSON.stringify(member)
    return await new Promise((resolve =&gt; {
        redis_client.zscore(key, member, (err, res) =&gt; {
            console.log(res)
            return resolve(res)
        })
    }))
}
redis.zscore = async (key, member) =&gt; {
    return tempZscore(key, member)
}

module.exports = redis;
</pre></div>
</div>
<p>需要对用户的Token进行时间控制，不能让其一直有效，否则只要获取了该Token的人都可以模拟用户进行操作。</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="o">//</span><span class="n">设置key的过期时间</span>
<span class="n">redis</span><span class="o">.</span><span class="n">expire</span> <span class="o">=</span> <span class="p">(</span><span class="n">key</span><span class="p">,</span> <span class="n">ttl</span><span class="p">)</span> <span class="o">=&gt;</span> <span class="p">{</span>
    <span class="n">redis_client</span><span class="o">.</span><span class="n">expire</span><span class="p">(</span><span class="n">key</span><span class="p">,</span> <span class="n">parseInt</span><span class="p">(</span><span class="n">ttl</span><span class="p">))</span>
<span class="p">}</span>
</pre></div>
</div>
<p>一些基本的ID应当考虑使用自增变量，这里封装一个Redis的自增ID获取方法，代码如下：</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="o">//</span><span class="n">获取自增id</span>
<span class="nb">id</span> <span class="o">=</span> <span class="k">async</span> <span class="p">(</span><span class="n">key</span><span class="p">)</span> <span class="o">=&gt;</span> <span class="p">{</span>
    <span class="n">console</span><span class="o">.</span><span class="n">log</span><span class="p">(</span><span class="s2">&quot;查找&quot;</span> <span class="o">+</span> <span class="n">key</span><span class="p">)</span>
    <span class="n">let</span> <span class="nb">id</span> <span class="o">=</span> <span class="k">await</span> <span class="n">new</span> <span class="n">Promise</span><span class="p">((</span><span class="n">resolve</span> <span class="o">=&gt;</span> <span class="p">{</span>
        <span class="n">redis_client</span><span class="o">.</span><span class="n">incr</span><span class="p">(</span><span class="n">key</span><span class="p">,</span> <span class="p">(</span><span class="n">err</span><span class="p">,</span> <span class="n">res</span><span class="p">)</span> <span class="o">=&gt;</span> <span class="p">{</span>
            <span class="n">console</span><span class="o">.</span><span class="n">log</span><span class="p">(</span><span class="n">res</span><span class="p">)</span>
            <span class="k">return</span> <span class="n">resolve</span><span class="p">(</span><span class="n">res</span><span class="p">)</span>
        <span class="p">})</span>
    <span class="p">}))</span>
    <span class="n">console</span><span class="o">.</span><span class="n">log</span><span class="p">(</span><span class="nb">id</span><span class="p">)</span>
    <span class="k">return</span> <span class="nb">id</span>
<span class="p">}</span>
<span class="n">redis</span><span class="o">.</span><span class="n">incr</span> <span class="o">=</span> <span class="k">async</span> <span class="p">(</span><span class="n">key</span><span class="p">)</span> <span class="o">=&gt;</span> <span class="p">{</span>
    <span class="k">return</span> <span class="k">await</span> <span class="nb">id</span><span class="p">(</span><span class="n">key</span><span class="p">)</span>
<span class="p">}</span>
</pre></div>
</div>
<p>虽然只使用k-v形式的JSON字符串，但是对于需要排序的内容，k-v形式过于烦琐，因此需要使用Redis中的有序序列进行一些数据的存储（类似于阅读量和热点文章等）。</p>
<p>在某些情况下会使用到Redis中的有序集合这个结构，例如在文章的阅读数量和热点获取时需要排序。</p>
<p>有序集合结构基于k-v基础，v中有一个member对象，对应一个score（分值），通过score可实现排序。如果读者不理解该结构，可以查阅有关资料。有序集合代码如下：</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span>//有序集合
//新增有序集合(键名，成员和分值)
redis.zadd = (key, member, num) =&gt; {
    member = JSON.stringify(member)
    redis_client.zadd(key, num, member, (err) =&gt; {
        if (err) {
            console.log(err)
        }
    })
}
//获取一定范围内的元素
tempData = async (key, min, max) =&gt; {
    let tData = await new Promise((resolve =&gt; {
        redis_client.zrevrange([key, min, max, &#39;WITHSCORES&#39;], (err, res) =&gt; {
            return resolve(res)
        })
    }))
    //同时获得了分值，所以需要进行转化为对象
    let oData = []
    //构造
    for (let i = 0; i &lt; tData.length; i = i + 2) {
        console.log(tData[i])
        oData.push({member: JSON.parse(tData[i]), score: tData[i + 1]})
    }
    return oData
}

redis.zrevrange = async (key, min = 0, max = -1) =&gt; {
    return tempData(key, min, max)
}

//有序集合的自增操作
redis.zincrby = (key, member, NUM = 1) =&gt; {
    member = JSON.stringify(member)
    redis_client.zincrby(key, NUM, member, (err) =&gt; {
        if (err) console.log(err)
    })
}

//有序集合通过member获取其score值
tempZscore = async (key, member) =&gt; {
    member = JSON.stringify(member)
    return await new Promise((resolve =&gt; {
        redis_client.zscore(key, member, (err, res) =&gt; {
            console.log(res)
            return resolve(res)
        })
    }))
}
redis.zscore = async (key, member) =&gt; {
    return tempZscore(key, member)
}

module.exports = redis;
</pre></div>
</div>
<p>注意：为了方便读者理解，对数据库的操作基本没有采用非JSON格式，但在真正的项目中，频繁地在代码中修改JSON对象并不适宜，采用Redis提供的散列或队列等结构效果会更好。</p>
<p>同时，为了使代码和数据逻辑更加清晰和简单，程序中没有采用事务等形式，而全部采用Redis的基本命令进行组合。在实际项目中，例如增加文章，同时需要对类型、标签和排序进行修改，这些数据库的操作都应当在同一个事务中，如果执行任意一个操作失败，将导致整个操作失败。</p>
</section>
<section id="id4">
<h2><a class="toc-backref" href="#id9"><span class="section-number">14.4. </span>4.配置服务应用列表</a><a class="headerlink" href="#id4" title="Permalink to this headline">¶</a></h2>
<p>（1）配置访问列表。在config文件夹中新建app.js文件，配置允许访问的应用名称，代码如下：</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">exports</span><span class="o">.</span><span class="n">ALLOW_APP</span> <span class="o">=</span> <span class="p">[</span><span class="s1">&#39;book&#39;</span><span class="p">]</span>
<span class="n">exports</span><span class="o">.</span><span class="n">NAME</span> <span class="o">=</span> <span class="s1">&#39;server&#39;</span>
</pre></div>
</div>
<p>（2）在前端传递一个代表该应用的参数，该参数存在于路径或post参数中，这样路径会显得有点“难看”，所以传递时可以将该参数附带在请求的头部。</p>
<p>在传递时，将该参数命名为fapp，也就是说，当请求头中的fapp字段为book字符串时，符合要求。在Express中，通过如下代码获取该参数：</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="o">//</span> <span class="n">获取所有的header参数</span>
<span class="n">console</span><span class="o">.</span><span class="n">log</span><span class="p">(</span><span class="n">req</span><span class="o">.</span><span class="n">headers</span><span class="p">)</span>

<span class="o">//</span> <span class="n">获取应用传递的参数</span>
<span class="n">req</span><span class="o">.</span><span class="n">headers</span><span class="o">.</span><span class="n">fapp</span>
</pre></div>
</div>
<p>（3）编写用户状态判定中间件。</p>
<p>所有的路由控制前都应当有用户是否处于登录状态的判断和区分，Express的中间件非常适合完成在访问路由时进行统一的用户状态判定。</p>
<p>中间件可以理解为一个独立于主要功能逻辑的代码块，用于实现一些附加的功能，可以在主要逻辑处理之前或处理之后进行访问，类似于Vue.js中的“守卫”。</p>
<p>在util文件夹中编写middleware.js文件，用于存放用户状态判定。该中间件实现的功能是对所有的用户请求进行头部判定，如果符合条件，则继续执行，如果不符合条件，则通过res.json返回一个错误。middleware.js文件的代码如下：</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span>const {ALLOW_APP} = require(&#39;../config/app&#39;)
const util = require(&#39;./common&#39;)

exports.checkAPP = (req, res, next) =&gt; {
    console.log(req.headers)
    if (!ALLOW_APP.includes(req.headers.fapp)) {
        res.json(util.getReturnData(500, &quot;来源不正确&quot;))
    } else {
        next()
    }
}
</pre></div>
</div>
<p>中间件可以使用next()对象进行下一步操作，此时的项目需求应当是在所有的路由头部执行该中间件，因此只有条件通过next()之后，才会执行主要的业务逻辑。</p>
<p>上述代码使用了util.js中的一个创建JSON格式化串的方法，可以在util文件夹中新建common.js文件，用于存放一些通用的方法或验证内容。代码如下：</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span>let util = {}
util.getReturnData = (code, message = &#39;&#39;, data = []) =&gt; {
    //保证数据格式
    if (!data) {
        data = []
    }
    return {code: code, message: message, data: data}
}

//转化为格式化时间
util.getLocalDate = (t) =&gt; {
    let date = new Date(parseInt(t))
    return date.getFullYear() + &quot;-&quot; + (parseInt(date.getMonth()) + 1) + &quot;-&quot; + date.getDate() + &quot; &quot; + date.getHours() + &#39;:&#39; + date.getMinutes() + &#39;:&#39; + date.getSeconds();
}

module.exports = util
</pre></div>
</div>
<blockquote>
<div><p>注意：箭头函数不需要花括号及显式的return，但为了统一格式，本书使用了显式的return。</p>
</div></blockquote>
<p>（4）引入中间件，因为所有对用户的请求都需要该中间件验证，所以直接在app.js中引入并使用。更改后的app.js代码如下：</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span>var createError = require(&#39;http-errors&#39;);
var express = require(&#39;express&#39;);
var path = require(&#39;path&#39;);
var cookieParser = require(&#39;cookie-parser&#39;);
var logger = require(&#39;morgan&#39;);

var indexRouter = require(&#39;./routes/index&#39;);
var usersRouter = require(&#39;./routes/users&#39;);
const {checkAPP} = require(&quot;./util/middleware&quot;);

var app = express();

// view engine setup
app.set(&#39;views&#39;, path.join(__dirname, &#39;views&#39;));
app.set(&#39;view engine&#39;, &#39;pug&#39;);

app.use(logger(&#39;dev&#39;));
app.use(express.json());
app.use(express.urlencoded({ extended: false }));
app.use(cookieParser());
app.use(express.static(path.join(__dirname, &#39;public&#39;)));

//
app.use(&#39;/&#39;, checkAPP,indexRouter);
app.use(&#39;/users&#39;, usersRouter);

// catch 404 and forward to error handler
app.use(function(req, res, next) {
  next(createError(404));
});

// error handler
app.use(function(err, req, res, next) {
  // set locals, only providing error in development
  res.locals.message = err.message;
  res.locals.error = req.app.get(&#39;env&#39;) === &#39;development&#39; ? err : {};

  // render the error page
  res.status(err.status || 500);
  res.render(&#39;error&#39;);
});

module.exports = app;
</pre></div>
</div>
<p>（5）编写一个测试路由，修改router文件夹中的index.js文件，修改后的代码如下：</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">var</span> <span class="n">express</span> <span class="o">=</span> <span class="n">require</span><span class="p">(</span><span class="s1">&#39;express&#39;</span><span class="p">);</span>
<span class="n">var</span> <span class="n">router</span> <span class="o">=</span> <span class="n">express</span><span class="o">.</span><span class="n">Router</span><span class="p">();</span>
<span class="n">const</span> <span class="n">util</span> <span class="o">=</span> <span class="n">require</span><span class="p">(</span><span class="s1">&#39;../util/common&#39;</span><span class="p">)</span>

<span class="o">//</span> <span class="n">获取footer显示内容</span>
<span class="n">router</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="s1">&#39;/getFooter&#39;</span><span class="p">,</span> <span class="n">function</span> <span class="p">(</span><span class="n">req</span><span class="p">,</span><span class="n">res</span><span class="p">,</span><span class="nb">next</span><span class="p">)</span> <span class="p">{</span>
  <span class="n">res</span><span class="o">.</span><span class="n">json</span><span class="p">(</span><span class="n">util</span><span class="o">.</span><span class="n">getReturnData</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span><span class="s1">&#39;success&#39;</span><span class="p">))</span>
<span class="p">});</span>
</pre></div>
</div>
<p>也就是说，当访问该路由http://localhost:3000/getFooter时，首先进行请求头的验证，只有验证成功了，才能接着执行路由对应的业务逻辑。</p>
<p>（5）使用Postman进行测试，如果没有增加任何请求头，则会返回一个错误信息提示</p>
<p>Postman可以在请求下方的Headers选项卡中填写任意的头部信息，该信息会同时发送给服务器端。</p>
<p>例如，在Headers中增加一个fapp=book，并且确定其处于勾选状态.请求之后，请求成功。</p>
</section>
</section>


           </div>
          </div>
          <footer><div class="rst-footer-buttons" role="navigation" aria-label="Footer">
        <a href="13.%E9%A1%B9%E7%9B%AE%E7%AD%96%E5%88%92%E5%92%8C%E5%8A%9F%E8%83%BD%E8%AE%BE%E8%AE%A1.html" class="btn btn-neutral float-left" title="13. 项目策划和功能设计" accesskey="p" rel="prev"><span class="fa fa-arrow-circle-left" aria-hidden="true"></span> Previous</a>
        <a href="15.%E9%80%9A%E7%94%A8API%E5%BC%80%E5%8F%91.html" class="btn btn-neutral float-right" title="15. 通用API开发" accesskey="n" rel="next">Next <span class="fa fa-arrow-circle-right" aria-hidden="true"></span></a>
    </div>

  <hr/>

  <div role="contentinfo">
    <p>&#169; Copyright 2019, huxiaojian.</p>
  </div>

  Built with <a href="https://www.sphinx-doc.org/">Sphinx</a> using a
    <a href="https://github.com/readthedocs/sphinx_rtd_theme">theme</a>
    provided by <a href="https://readthedocs.org">Read the Docs</a>.
   

</footer>
        </div>
      </div>
    </section>
  </div>
  <script>
      jQuery(function () {
          SphinxRtdTheme.Navigation.enable(true);
      });
  </script> 

</body>
</html>