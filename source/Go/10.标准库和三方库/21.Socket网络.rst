.. contents::
   :depth: 3
..

Socket网络
==========

1.TCP编程
---------

TCP协议
~~~~~~~

TCP/IP(Transmission Control Protocol/Internet Protocol)
即传输控制协议/网间协议，是一种面向连接（连接导向）的、可靠的、基于字节流的传输层（Transport
layer）通信协议，因为是面向连接的协议，数据像水流一样传输，会存在黏包问题。

1.1 Go语言实现TCP通信示例1
~~~~~~~~~~~~~~~~~~~~~~~~~~

TCP服务器
^^^^^^^^^

TCP服务端程序的处理流程：

::

   1.监听端口    
   2.接收客户端请求建立链接    
   3.创建goroutine处理链接。

tcp_server.go

.. code:: go

   package main

   import (
       "bufio"
       "fmt"
       "io"
       "net"
       "time"
   )

   func main() {
       var tcpAddr *net.TCPAddr
       tcpAddr, _ = net.ResolveTCPAddr("tcp", "127.0.0.1:999")
       tcpListener, _ := net.ListenTCP("tcp", tcpAddr)
       defer tcpListener.Close()
       fmt.Println("Server ready to read .....")
       for {
           tcpConn, err := tcpListener.AcceptTCP()
           if err != nil {
               fmt.Println("accept error:", err)
               continue
           }
           fmt.Println("A client connected :" + tcpConn.RemoteAddr().String())
           go tcpPipe(tcpConn)
       }
   }

   func tcpPipe(conn *net.TCPConn) {
       ipStr := conn.RemoteAddr().String()
       defer func() {
           fmt.Println("Disconnected : " + ipStr)
           conn.Close()
       }()

       reader := bufio.NewReader(conn)
       i := 0
       for {
           message, err := reader.ReadString('\n') //将数据按照换行符进行读取
           if err != nil || err == io.EOF {
               break
           }
           fmt.Println(string(message))
           time.Sleep(time.Second * 3)

           msg := time.Now().String() + conn.RemoteAddr().String() + " Server say hello! \n"
           b := []byte(msg)
           conn.Write(b)
           i++
           if i > 10 {
               break
           }
       }

   }

TCP客户端
^^^^^^^^^

一个TCP客户端进行TCP通信的流程如下：

::

   1.建立与服务端的链接    
   2.进行数据收发    
   3.关闭链接

tcp_client.go

.. code:: go

   package main

   import (
       "bufio"
       "fmt"
       "io"
       "net"
       "time"
   )

   func main() {
       var tcpAddr *net.TCPAddr
       tcpAddr, _ = net.ResolveTCPAddr("tcp", "127.0.0.1:999")
       conn, err := net.DialTCP("tcp", nil, tcpAddr)
       if err != nil {
           fmt.Println("Client connect error !" + err.Error())
           return
       }

       defer conn.Close()
       fmt.Println(conn.LocalAddr().String() + " : Client connected!")
       onMessageRecived(conn)

   }

   func onMessageRecived(conn *net.TCPConn) {
       reader := bufio.NewReader(conn)
       b := []byte(conn.LocalAddr().String() + " Say hello to Server ....\n")
       conn.Write(b)
       for {
           msg, err := reader.ReadString('\n')
           fmt.Println("ReadString")
           fmt.Println(msg)
           if err != nil || err == io.EOF {
               fmt.Println(err)
               break
           }
           time.Sleep(time.Second * 2)
           fmt.Println("writing ...")

           b :=[]byte(conn.LocalAddr().String() + " write data to Server .... \n ")
           _,err = conn.Write(b)

           if err != nil {
               fmt.Println(err)
               break
           }
       }
   }

1.2 Go语言实现TCP通信示例2
~~~~~~~~~~~~~~~~~~~~~~~~~~

.. _tcp服务器-1:

TCP服务器
^^^^^^^^^

.. code:: go

   package main

   import (
       "bufio"
       "fmt"
       "net"
   )

   // 处理函数
   func process(conn net.Conn) {
       defer conn.Close() // 关闭连接
       for {
           reader := bufio.NewReader(conn)
           var buf [128]byte
           n, err := reader.Read(buf[:]) // 读取数据
           if err != nil {
               fmt.Println("read from client failed, err:", err)
               break
           }
           recvStr := string(buf[:n])
           fmt.Println("收到client端发来的数据：", recvStr)
           conn.Write([]byte(recvStr)) // 发送数据
       }
   }
   func main() {
       listen, err := net.Listen("tcp", "127.0.0.1:20000")
       if err != nil {
           fmt.Println("listen failed, err:", err)
           return
       }
       for {
           conn, err := listen.Accept() // 建立连接
           if err != nil {
               fmt.Println("accept failed, err:", err)
               continue
           }
           go process(conn) // 启动一个goroutine处理连接
       }
   }

.. _tcp客户端-1:

TCP客户端
^^^^^^^^^

.. code:: go

   package main

   import (
       "bufio"
       "fmt"
       "net"
       "os"
       "strings"
   )

   //客户端
   func main() {
       conn, err := net.Dial("tcp", "127.0.0.1:20000")
       if err != nil {
           fmt.Println("err :", err)
           return
       }
       defer conn.Close() // 关闭连接
       inputReader := bufio.NewReader(os.Stdin)
       for {
           input, _ := inputReader.ReadString('\n') // 读取用户输入
           inputInfo := strings.Trim(input, "\r\n")
           if strings.ToUpper(inputInfo) == "Q" { // 如果输入q就退出
               return
           }
           _, err = conn.Write([]byte(inputInfo)) // 发送数据
           if err != nil {
               return
           }
           buf := [512]byte{}
           n, err := conn.Read(buf[:])
           if err != nil {
               fmt.Println("recv failed, err:", err)
               return
           }
           fmt.Println(string(buf[:n]))
       }
   }

2.UDP编程
---------

UDP协议
~~~~~~~

UDP协议（User Datagram Protocol）中文名称是用户数据报协议，是OSI（Open
System
Interconnection，开放式系统互联）参考模型中一种无连接的传输层协议，不需要建立连接就能直接进行数据发送和接收，属于不可靠的、没有时序的通信，但是UDP协议的实时性比较好，通常用于视频直播相关领域。

2.1 GO语言实现UDP通信示例
~~~~~~~~~~~~~~~~~~~~~~~~~

UDP服务端
^^^^^^^^^

.. code:: go

   package main

   import (
       "fmt"
       "net"
   )

   // UDP/server/main.go
   // UDP server端
   func main() {
       listen, err := net.ListenUDP("udp", &net.UDPAddr{
           IP:   net.IPv4(0, 0, 0, 0),
           Port: 30000,
       })
       if err != nil {
           fmt.Println("listen failed, err:", err)
           return
       }
       defer listen.Close()
       for {
           var data [1024]byte
           n, addr, err := listen.ReadFromUDP(data[:]) // 接收数据
           if err != nil {
               fmt.Println("read udp failed, err:", err)
               continue
           }
           fmt.Printf("data:%v addr:%v count:%v\n", string(data[:n]), addr, n)
           _, err = listen.WriteToUDP(data[:n], addr) // 发送数据
           if err != nil {
               fmt.Println("write to udp failed, err:", err)
               continue
           }
       }
   }

UDP客户端
^^^^^^^^^

.. code:: go

   package main

   import (
       "fmt"
       "net"
   )

   // UDP 客户端
   func main() {
       socket, err := net.DialUDP("udp", nil, &net.UDPAddr{
           IP:   net.IPv4(0, 0, 0, 0),
           Port: 30000,
       })
       if err != nil {
           fmt.Println("连接服务端失败，err:", err)
           return
       }
       defer socket.Close()
       sendData := []byte("Hello server")
       _, err = socket.Write(sendData) // 发送数据
       if err != nil {
           fmt.Println("发送数据失败，err:", err)
           return
       }
       data := make([]byte, 4096)
       n, remoteAddr, err := socket.ReadFromUDP(data) // 接收数据
       if err != nil {
           fmt.Println("接收数据失败，err:", err)
           return
       }
       fmt.Printf("recv:%v addr:%v count:%v\n", string(data[:n]), remoteAddr, n)
   }

解决TCP粘包现象
~~~~~~~~~~~~~~~

参考资料:

https://www.bookstack.cn/read/topgoer/a680d3a9bb345056.md
